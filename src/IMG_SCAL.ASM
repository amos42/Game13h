;*****************************************
;
;     모드 13h용 게임 작성 라이브러리
;                       Ver 4.2
;
;                 제작자:
;                        주 경 민
;
;  게임 작성을 위해 만든 라이브러리로서
; 모드 13h (320x200, 256) 전용이다.
;
;*****************************************
IDEAL
include "game13h.inc"


UDATASEG


DATASEG


CODESEG

;*******************************************
;  이미지를 가로 세로 각각 x, y배 확대한다.
; void image_scale( int x, int y, image_data original_image, word scale_x, word scale_y )
;*******************************************
proc image_scale  x:word, y:word, original_image:dword, scale_x:word, scale_y:word
  local size_x, size_y, length : word
  uses ds, es, si, di

  set_page es, [_page_number]
  calc_addr di, [x], [y]

  lds si, [original_image]

  cld

  lodsw
  mov [size_x], ax
  mov bx, [scale_x]
  mul bx
  mov [length], ax
  lodsw
  mov cx, ax
  dec [scale_y]

  mov dx, H_RES
  sub dx, [length]

  ; state :
  ;  ds:si ... 이미지의 시작 주소
  ;  es:di ... 화면의 시작위치
  ;  bx ... x축 확대 비을
  ;  cx ... 원래의 y크기
  ;  dx ... crage (320 - length)

 @@y_loop:
  push cx

  mov cx, [size_x]
 @@put_x_pixel:
  lodsb       ; 점을 읽어 scale_x번 찍는다.
  push cx
  mov cx, bx
  rep stosb
  pop cx
  loop @@put_x_pixel

  mov cx, [scale_y]
  jcxz @@y_skip

  ; 한줄을 y번 셔트한다(셔로 확대를 구현한다).
  push ds si

  mov si, di
  add di, dx  ; 다음줄 시작위치
  mov ax, es
  mov ds, ax

 @@put_y_pixel:
  mov ax, cx  ; push cx

  mov cx, [length]
  sub si, cx  ; si를 x사이즈만큼 후툐
  shr cx, 1
  jnc @@skip
  movsb
 @@skip:
  rep movsw
  add di, dx

  mov cx, ax  ; pop cx
  loop @@put_y_pixel

  pop si ds
  jmp @@y_no_skip

 @@y_skip:
  add di, dx

 @@y_no_skip:
  pop cx
  cmp di, 64000d
  jae @@exit
  loop @@y_loop

 @@exit:
  ret
endp
global image_scale : proc


END
