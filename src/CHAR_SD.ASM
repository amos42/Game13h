;*****************************************
;
;     모드 13h용 게임 작성 라이브러리
;                       Ver 4.2
;
;                 제작자:
;                        주 경 민
;
;  게임 작성을 위해 만든 라이브러리로서
; 모드 13h (320x200, 256) 전용이다.
;
;*****************************************
IDEAL
include "game13h.inc"


UDATASEG


DATASEG


CODESEG


;*****************************
;  캐릭터의 그림자만 찍는다.
; void char_put_shade( int x, int y, image_data image, char shade )
;*****************************
proc char_put_shade  x:word, y:word, image:dword, shade:byte
  uses ds, es, si, di

  ; es:di ... 그래픽 세그먼트, 오프셋 세트
  set_page es, [_page_number]
  calc_addr di, [x], [y]

  mov ah, [_attr_null_color]    ; ah ... skip_color
  mov al, [shade]               ; al ... shade_color

  ; si ... 이미지 배열의 시작점 */
  lds si, [image]

  mov bx, [ds:si]    ; bx ... 이미지의 x 크기
  test bx, bx
  jz @@exit
  mov cx, [ds:si+2]  ; cx ... 이미지의 y 크기를 셔트
  jcxz @@exit
  add si, 4

  mov dx, H_RES
  sub dx, bx         ; dx ... 320 - x_size

  ; state :
  ;   ds:si ... 배열의 이미지 시작부분
  ;   es:di ... 화면상의 이미지 시작부분
  ;   ah ... skip_color
  ;   al ... shade
  ;   bx ... x_size
  ;   cx ... y_size
  ;   dx ... carage (320 - x_size)

 @@y_loop:
  push cx
  mov cx, bx

 @@x_loop:
  cmp ah, [ds:si]
  je @@skip
  add [es:di], al
 @@skip:
  inc si
  inc di
  loop @@x_loop

  pop cx
  add di, dx
  loop @@y_loop

 @@exit:
  ret
endp
global char_put_shade : proc


;**********************************
;   char_put_shade의 클리핑 버전
; void char_put_shade_clip( int x, int y, image_data image, char shade )
;**********************************
proc char_put_shade_clip  x:word, y:word, image:dword, shade:byte
  local image_carage:word, screen_carage:word
  local temp:word
  uses ds, es, si, di

  mov ah, [_attr_null_color]    ; ah ... skip_color
  mov al, [shade]               ; al ... shade
  mov [temp], ax

  set_page es, [_page_number]  ; es ... 그래픽 셔그먼트 셔트
  lds si, [image]              ; ds:bx ... 이미지 배열의 시작점

  mov bx, [ds:si]     ; dx ... 이미지의 x 크기
  test bx, bx
  jz @@exit
  mov cx, [ds:si+2]   ; cx ... 이미지의 y 크기를 셔트
  jcxz @@exit
  add si, 4
  mov [image_carage], bx

  ; clipping y
  mov ax, [y]
  call _clipping_y
  jcxz @@exit

  calc_addr di, [x], ax

  ; clipping x
  mov ax, [x]
  call _clipping_x
  test bx, bx
  jz @@exit

  ; screen carage ... 320 - x_size
  mov [screen_carage], H_RES
  sub [screen_carage], bx

  sub [image_carage], bx   ; 이미지 배열의 캐리지값

  ; dh ... skip color
  ; dl ... shade
  mov dx, [temp]

  ; state :
  ;   ds:si ... 배열의 이미지 시작부분
  ;   es:di ... 화면상의 이미지 시작부분
  ;   bx ... x_size
  ;   cx ... y_size
  ;   dh ... skip color
  ;   dl ... shade

  cld

 @@y_loop:
  push cx
  mov cx, bx

 @@x_loop:
  lodsb
  cmp al, dh
  je @@skip
  add [es:di], dl
 @@skip:
  inc di
  loop @@x_loop

  add si, [image_carage]
  add di, [screen_carage]
  pop cx
  loop @@y_loop

 @@exit:
  ret
endp
global char_put_shade_clip : proc


END
