;*****************************************
;
;     모드 13h용 게임 작성 라이브러리
;                       Ver 4.2
;
;                 제작자:
;                        주 경 민
;
;  게임 작성을 위해 만든 라이브러리로서
; 모드 13h (320x200, 256) 전용이다.
;
;*****************************************
IDEAL
include "game13h.inc"


UDATASEG


DATASEG


CODESEG

;***************************
; copy_put()의 y클리핑 버전
; void copy_put_clip_y( int x, int y, image_data image )
;****************************
proc copy_put_clip_y  x, y : word, image : dword
  uses ds, es, si, di

  ; es ... 그래픽 세그먼트 세트
  set_page es, [_page_number]

  ; bx ... 이미지 배열의 시작점
  lds si, [image]

  mov bx, [ds:si]    ; bx ... 이미지의 x 크기
  test bx, bx
  jz @@exit
  mov cx, [ds:si+2]  ; cx ... 이미지의 y 크기를 세트 */
  jcxz @@exit
  add si, 4

  ; clipping y
  mov ax, [y]            ; 클리핑 하기 전에 ax를 세트
  call _clipping_y 
  jcxz @@exit

  calc_addr di, [x], ax  ; di ... 그래픽 오프셋

  mov dx, H_RES
  sub dx, bx       ; ax ... 320 - x_size

  ; state :
  ;   ds:si ... 배열의 이미지 시작부분
  ;   es:di ... 화면상의 이미지 시작부분
  ;   bx ... x_size
  ;   cx ... y_size
  ;   dx ... carage (320 - x_size)

  cld

 @@loop:
  mov ax, cx  ; push cx
  mov cx, bx

  shr cx, 1
  jnc @@skip
  movsb
  jcxz @@next
 @@skip:
  rep movsw

 @@next:
  add di, dx
  mov cx, ax  ; pop cx
  loop @@loop

 @@exit:
  ret
endp
global copy_put_clip_y : proc


;****************************
;  copy_put()의 x클리핑 버전
; void copy_put_clip_x( int x, int y, image_data image )
;****************************
proc copy_put_clip_x  x, y : word, image : dword
  local temp:word
  uses ds, es, si, di

  ; es ... 그래픽 세그먼트 세트 */
  set_page es, [_page_number]

  ; ds:si ... 이미지 배열의 시작점 */
  lds si, [image]

  mov bx, [ds:si]    ; dx ... 이미지의 x 크기
  test bx, bx
  jz @@exit
  mov cx, [ds:si+2]  ; cx ... 이미지의 y 크기를 세트
  jcxz @@exit
  add si, 4

  calc_addr di, [x], [y]
  mov [temp], bx  ; bx ... Orignal size X

  ; clipping x
  mov ax, [x]
  call _clipping_x
  test bx, bx
  jz @@exit

  mov dx, H_RES
  sub dx, bx      ; ax ... 320 - x_size

  ; ax ... 이미지 배열의 캐리지값
  mov ax, [temp]  ; ax ... Orignal size X
  sub ax, bx      ; ax ... New X - Old X

  ; state :
  ;   ds:si ... 배열의 이미지 시작부분
  ;   es:di ... 화면상의 이미지 시작부분
  ;   ax ... image carage
  ;   bx ... x_size
  ;   cx ... y_size
  ;   dx ... screen carage (320 - x_size)

  cld

 @@loop:
  push cx
  mov cx, bx

  shr cx, 1
  jnc @@skip
  movsb
  jcxz @@next
 @@skip:
  rep movsw

 @@next:
  add si, ax
  add di, dx
  pop cx
  loop @@loop

 @@exit:
  ret
endp
global copy_put_clip_x : proc


;***************************
; copy_put()의 클리핑 버전
; void copy_put_clip( int x, int y, image_data image )
;***************************
proc copy_put_clip  x, y : word, image : dword
  local temp:word
  uses ds, es, si, di

  ; es ... 그래픽 세그먼트 세트
  set_page es, [_page_number]

  ; ds:si ... 이미지 배열의 시작점
  lds si, [image]

  mov bx, [ds:si]     ; dx ... 이미지의 x 크기
  test bx, bx
  jz @@exit
  mov cx, [ds:si+2]   ; cx ... 이미지의 y 크기를 세트
  jcxz @@exit
  add si, 4

  ; clipping y
  mov ax, [y]
  call _clipping_y
  jcxz @@exit

  calc_addr di, [x], ax
  mov [temp], bx     ; bx ... Orignal size X

  ; clipping x
  mov ax, [x]
  call _clipping_x
  test bx, bx
  jz @@exit

  mov dx, H_RES
  sub dx, bx     ; ax ... 320 - x_size

  ; ax ... 이미지 배열의 캐리지값
  mov ax, [temp] ; ax ... Orignal size X
  sub ax, bx     ; ax ... New X - Old X

  ; state :
  ;   ds:si ... 배열의 이미지 시작부분
  ;   es:di ... 화면상의 이미지 시작부분
  ;   ax ... image carage (x_size + org_x_size)
  ;   bx ... x_size
  ;   cx ... y_size
  ;   dx ... screen carage (320 - x_size)

  cld

 @@loop:
  push cx
  mov cx, bx

  shr cx, 1
  jnc @@skip
  movsb
  jcxz @@next
 @@skip:
  rep movsw

 @@next:
  add si, ax
  add di, dx
  pop cx
  loop @@loop

 @@exit:
  ret
endp
global copy_put_clip : proc


END
