

                          모드 13h 전용 라이브러리
                                       (게임 제작용 버전 4.2)
                               >>> 유저 가이드 <<<

                                                                    제작자 : 주 경 민 





  1) 컴파일 방법

  우선 이 라이브러리의 사용에 대한 대상을 초급에서 중급으로 넘어가는 사용자라고 가정하고 이 메뉴얼을 
작성한다. 그러므로 프로젝트에 관해 잘 모르는 사람도 있을 것이라고 생각되어 먼저 프로젝트의  사용법부
터 설명하려 한다. 프로젝트는 터보 C Ver 1.5를 쓰던 사람들에게는 익숙하리라 생각된다. 1.5에 있는 그래
픽 라이브러리는 터보 C에서 직접 링크해 주지 않으므로 자신이 프로젝트로 직접 링크했어야 했다. 만약 그
런 경험이 있다면 여기서 설명하는 사항은 그냥 넘어가도 되지만, 그렇지 않다면 이 곳을 숙지하기 바란다. 
이것을 모른다면 이 라이브러리를 아예 사용하지도 못하기 때문이다. 먼저 자신이 이 라이브러리를  이용해
서 프로그램을 작성했고, 그 프로그램의 이름을 FILENAME.C라고 가정한다. 그러면 프로젝트는 이렇게  제작
하며 이름은 FILENAME.PRJ라고 한다. 프로젝트의 이름은 자유로이 정할 수 있지만 이왕이면 그 화일 이름과 
같게 해 주는게 여러모로 편리하다. 버전 2.XX까지는 프로젝트에  GAME13H.OBJ라  써  넣었지만  3.0부터는 
GAME13H.LIB로 바뀌었다. 이 라이브러리는 라이브러리 디렉토리에 존재해야 한다.

  FILENAME.C
  GAME13H.LIB

  이렇게 에디터를 이용해서 만들어 주고 터보 C의 메뉴에서 프로젝트를 선택해 주면 실행할  때  자동으로 
FILENAME.C를 컴파일 해서 GAME13H.LIB과 링크해 준다. 단, 메모리 모델은 LARGE로 해 주어야 하고  컴파일 
모드는 80186/80286모드로 해야만 한다. 또하나, 이때 GAME13H.LIB는 TC의 LIB디렉토리에, GAME13H.H는  TC
의 INCLUDE디렉토리에 넣어야만 한다.
  볼랜드 C++을 쓰는 사람의 경우엔 라이브러리 만드는 것이 훨씬 간단하다. IDE(통합개발환경)에서 다  제
공해 주기 때문이다. 또한 BC를 쓸 경우엔 C++의 향상된 문법을 사용할 수 있다. 단, 이 경우엔 C모드로 컴
파일 한다면 그냥 GAME13H.H를 인클루드 하면 되지만 C++모드로 컴파일 하려면 별도로 제공된  GAME13H.HPP
를 인클루드 해야만 한다. 두 모드를 전환하는 것은 간단히 컴파일 하고자 하는 소스의 확장자가 C인가 CPP
인가에 달려있다.
  또 한가지, 편리한 방법이 있다. 이 라이브러리를 자주 사용하게 될 경우 이 라이브러리를 아예 터보 C의 
표준 라이브러리로 등록시킬 수 있게 하는 방법이다. 대신 터보 C의 표준 라이브러리중 GRAPHICS.LIB는  희
생시켜야 한다. 그러나 게임 제작하는 사람에게는 그래픽 라이브러리를 사용할 필요가 없으므로 그다지  걱
정할 필요가 없다고 생각한다. 방법은 PC-TOOLS이나 DISKEDIT.EXE와 같은 섹터 에디트 기능이 있는 툴을 사
용하는 것이다. 섹터 에디터의 FIND기능을 이용해서 TC.EXE에서 GRAPHIC를 찾는다. 아마 두개가 있을  것이
다. 하나는  터보  C의  풀다운  메뉴에  나오는  항목이고  하나는  라이브러리화일  이름이다.  첫번째는 
"GRAPHICS.LIB"를 라이브러리 이름인 "GAME13H.LIB"로 바꾸어 주고,("GRAPHICS.LIB"가 "GAME13H.LIB"보다 1
자가 더 많으므로 "GAME13H.LIB"의 뒤에 한 문자는 아스키 코드 00으로 채워야 한다.)  두번째  찾은  것은 
"Graphics" 를 "Game 13h"로 바꾸어 주면 된다. 그러면 앞으로 프로젝트 화일을 만들 필요가 없어진다.  물
론 분할 컴파일을 할 때는 어쩔 수 없지만... 라이브러리 유틸리티로서 함께 포함된 PATCH.COM을  TC.EXE가 
있는 곳에서 실행시키면 이 작업을 자동으로 해 준다. 원래대로 돌리려면  UNPATCH.COM을  사용한다.  물론 
Turbo C Ver 2.0의 경우에만이다. 이 두 화일은 TC_PATCH.ZIP에 포함되어 있다. Borland C++ 3.1의  경우엔 
BC_PATCH.ZIP에 합축된 PATCH.COM과 UNPATCH.COM을 쓰면 된다.



  2) 라이브러리의 실제


  1) 라이브러리의 초기화

  라이브러리에서 가장 기본이 되는 함수는 init_game13h()와 close_game13h()이다. init_game13h()는 바로 
이 라이브러리를 쓰기에 앞서 그래픽 모드를 초기화 하는 작업을 한다. 이 함수가 해 주는 역할은 우선  그
래픽 모드는 모드 13h(320x200, 256c)로 바꾸어 주고 팔레트를 딜럭스 페인트 표준 팔레트로 바꾸는 작업이
다. 이에 반해 close_game13h()는 텍스트 모드로 되돌리고 몇가지 처리만을 한다. 또한 이 라이브러리는 외
부 툴에 많은 부분을 의존하고 있다. 예를 들어 GPG화일을 만드는 LBM2GPG.EXE와 같은  종류의  프로그램이
다. 보통 이에 해당하는 툴들은 라이브러리와 함께 제공되니 PATH를 걸어놓은 디렉토리에 모두 복사한 다음
에 MDIR이나 NC와 같은 쉘에 등록시키면 편리하게 사용할 수 있다.


  2) 맛보기 예제

  우선 간단한 프로그램을 작성해 보자. 이 프로그램은 모드를 13h로 바꾸어 주고 그곳의 한 가운데에 윈도
우를 열어준 다음 다시 닫는 프로그램이다. BC 사용자의 경우엔 첫행의 game13h.h를 game13h.hpp로 바꿔 주
기만 하면 된다.

  #include <game13h.h>  /* Ver 4.2 */

  main()
  {
    window_data window;

    init_game13h();
    clear_screen( BLUE );

    center_window( 100, 50, &window );
    delay_key();
    close_window(, &window );
    delay_key();

    close_game13h();
  }

  여기서 맨 윗줄의 include문은 이 라이브러리의 헤더를 포함하는 구절이다. 항상 함수를 쓰기 전에 그 함
수의 헤더를 인클루드 하는 습관을 들여야 하겠다. 특히나 Game13h는 헤더화일이 없으면  제대로  컴파일이 
되지 않는다. 이 헤더화일엔 함수의 선언과 각 전역변수, 그리고 각종 매크로 상수에 대한  선언이  들어있
다. 또한 필요하다고 생각하는 몇가지 헤더는 여기서 함께 읽어들이니 game13h.h를 보고 겹치는 헤더는  빼
도 된다. 하나 염두해 둘 것은 이 헤더 옆에 위에서와 같이 버전을 써두는 것이다. 이것은 이 라이브러리의 
특수성에 기인하는 것인데 이 라이브러리는 하위 버전과 호환성이 떨어진다. 그러니 버전을 프로그램의  앞
에 항상 명시해 두어야 한다. 위 프로그램에서 주의 깊게 들여다 봐야 할 것은 바로 함수를 사용하는  형식
이다. 이 라이브러리의 가장 편리한 함수중에 하나인 center_window()함수는 요구하는 인수가 많기  때문에 
약간의 주의를 요한다. 첫번째, 두번째 함수는 각각 모드를 원하는 모드로 바꾸고 원하는 색깔로 화면을 지
우는 역할을 하고, 그다음 윈도우를 열게 된다. 윈도우를 연 후에는 반드시 close_window()로 다시 그 윈도
우를 닫아야 한다는 점을 명심하라. 그렇지 않으면 나중에 메모리가 모자라서 시스템이 정지해 버리는 경우
가 생긴다. 윈도우를 여는 함수들은 모두 버퍼를 이용하는데 이것은 다시 윈도우를 닫을  때를  대비해서이
다. 이 때문에 메모리를 해제해 주는 작업을 따로 해 주어야 하는데 이 작업을 close_window()가 해  준다. 
뿐만 아니라 이 작업은 열린 윈도우를  닫고  원래  화면으로  복구시켜주는  역활까지  해  준다.  여기서 
center_window(), close_window()의 원형은 뒤에 설명하기로 한다. 이제 문자를 써 보자. make_str()은  문
자열을 출력하는  함수인데,  아래에  그  예를  보인다.  4.1까지  있었던  인수인  지연시간은  전역변수 
_message_delay로 대치되어 삭제되었다.

  #include <game13h.h>

  main()
  {
    init_game13h();

    make_str( 50, 50, "안녕하세요. 데모입니다.", WHITE );
    delay_key();

    close_game13h();
  }

  make_str()보다는 좀더 나은 함수가 있다. make_str_double()이라는 함수인데 이 함수는 글씨에 그림자를 
주어 입체적으로 보이게 할 수 있다. 그림자의 색은 전역변수 _attr_shadow_color에 세트되어 있는데  초기
값은 BLACK이다. _attr_shadow_color는 4.1 이전의 버전에 있었던 _attr_shade_color를  변형시킨  것이다. 
그러므로 _attr_shade_color은 4.2에선 사용할 수 없다.
  무엇보다도 편리한 함수는 위의 두 함수를 합쳐 놓은 make_message()함수이다. 이 함수는 기본적으로  쓰
임이 center_window()와 비슷하지만 윈도우를 열고 그곳에 메세지까지 표현한다는 점에서 다르다. 뿐만  아
니라 다시 윈도우를 닫고 메모리를 해제시켜주기까지 한다. 단, 이 함수의 메세지가 되는  데이터는  2차원 
배열이어야 한다. 다음에 그 예를 보인다.

  #include <game13h.h>

  main()
  {
    char *message[] = { "안녕 하세요 ?",
                        "윈도우 데모입니다.",
                        "감사합니다.", };

    init_game13h();
    make_message( message, 3 );
    close_game13h();
  }


   3) 그림화일 사용법

  라이브러리 4.1 이전엔 변형 PCX화일인 DAT화일을 이용했는데 4.1부터는 제대로 형식을  갖춘  GPG화일을 
이용한다. GPG화일은 Game Picture Group의 약자로 이름에서와 같이 그림 여러개가  한  화일에  들어간다. 
GPG화일은 최대 64개까지 그림을 넣을 수 있는데, 그 이상의 화일을 넣을 바엔 차라리 화일 하나를 더 만드
는 것이 관리면에서 더 편하다고 생각하여 그 갯수를 64개로 제한한 것이다. GPG화일은 기본적으로 GPG화일
의 헤더가 있고 각 그림마다 청크 헤더가 있다. 화일의 헤더는 우선 화일의 식별부인  head_id라는  항목이 
있는데 이곳에 들어간 값은 "Game13h Picture"이다. version은 현재 1h로 되어 있으면 number는 현재 GPG화
일에 총 몇개의 그림이 들어가 있는가를 나타내는 변수이다. 그리고 offset은 각각의 그림들이 들어가 있는 
오프셋 주소이다. 예를들어 만약 3번째 그림이 오프셋 주소 10000번지에 들어가 있다면 라이브러리  내부에
선 leek( f, 10000, SEEK_SET )로 화일 포인터를 옮긴후 그림을 읽게 되는 것이다. 각각의  그림은  하나의 
청크 헤더를 갖고 있는데, 이 청크 헤더가 갖고 있는 내용은 단순하다. 우선 현재 그림의 사이즈를  저장한 
size라는 변수가 있다. 주의할 것은 이 size가 청크 헤더와 팔레트 정보를 제외한 크기라는 것이다. 그러니 
순수하게 RLE로 압축된 데이터의 크기인 셈이다. rle_flag는 이미지가 압축이 되어 있는지를 저장하는 플랙
이고 pal_flag는 현재 청크의 이미지가 팔레트를 포함하고 있는지를 저장하는 플랙이다. 그러니 실제로  그
림을 읽는 과정은 다음과 같다. 우선 화일의 헤더를 읽어 몇가지 검사를 한다. 그 다음에 몇번째 그림을 로
드할 것인가를 살펴보고 offset[]를 이용해 그 이미지가 있는 곳으로 화일 포인터를 옮긴다. 그 다음에  청
크 헤더를 읽어서 이미지가 팔레트를 가지고 있는가 아닌가를 알아낸다. 만약 팔레트를 포함한  이미지라면 
먼저 팔레트를 읽는다. 다음에 size라는 변수를 이용해 메모리를 할당하고 한번에 이미지를 읽는다. 그리고 
마지막으로 rle_flag를 살펴 이에 해당하는 방법으로 이미지를 전개하는 것이다. 참고로 RLE방식으로  압축
된 이미지를 푸는 함수는 incode_picture()이다. 아래에 실제 GPG화일의 헤더가 있다.

  struct picture_header {
             char head_id[15 + 1];
             byte ver;
             byte number;
             dword offset[64];
            };
  struct pic_chunk_head {
             word size;
             char rle_flag;
             char pal_flag;
            };

  그림을 로드하는 함수는 load_picture()이다. 이 함수는 화일의 이름과 로드할 그림의 번호를 인수로  주
면 그에 해당하는 그림을 로드하여 현재 페이지에 푼다. 아래 프로그램은 TEST.GPG라는 화일을 읽어 그  안
에 들어 있는 그림 전부를 차례대로 보여주는 프로그램이다.

  #include <game13h.h>

  main()
  {
    int i;

    init_game13h();

    for( i = 0; i < 64; i ++ ){
      if( load_picture( "TEST.GPG", i ) ) break;
      delay_key();
     }

    close_game13h();
  }

  GPG화일을 만드는 방법은 직접 라이브러리를 써서 만들어도 상관 없지만 실제론  LBM화일이나  PCX화일을 
변형시켜 만든다. 라이브러리에 함께 포함된 유틸리티 LBM2GPG.EXE, PCX2GPG.EXE와 GPGMERGE.EXE를  이용해
서 만들면 된다. LBM2GPG.EXE, PCX2GPG.EXE는 각각 LBM화일과 PCX화일을 GPG화일로 바꾸어 주는 유틸리티이
고, GPGMERGE.EXE는 GPG화일 두개를 이어서 새로운 GPG화일로 연결시켜 주는 것이다.


  4) 이미지 다루기

  이미지라 하면 보통 get_image()로 잡은 화면의 조각을 지칭하는데 실은 그 의미가 훨씬 광범위하다.  그
러나 여기선 흔히 통용되는 화면상의 그림 조각을 저장한 것을 뜻하기로 한다. 이미지의 구조는  단순하다. 
앞에 4바이트의 헤더가 있고 나머지는 그대로 이미지의 데이터가 들어있다. 이 이미지는 압축이 되지  않은 
관계로 상당히 메모리를 많이 차지한다. 예를 들어 20x10 크기의 이미지는 --모드 13h는 점하나가  1바이트
를 차지하므로-- 20 x 10 + 4 = 204바이트의 메모리를 차지한다. 헤더인 4바이트는 각각 x, y크기가  2바이
트씩을 차지하는 구조로 되어 있다. 이미지를 찍는 원리는 앞의 헤더에서 얻은 x, y크기대로 화면에 이미지
를 한줄씩 x크기만큼 y번 반복해서 찍는 것이다. 이 라이브러리에선 get_image()가 포인터의 포인터를 인수
로 받아 미리 메모리를 할당해 주므로 사용이 끝나면 farfree()로 그 메모리를 해제시켜야 한다. 그렇지 않
으면 나중에 메모리가 부족해서 프로그램이 다운되거나 하는 사태가 발생한다. get_image()와 비슷하나  스
스로 메모리를 할당하지 않고 주어진 포인터에 잡은 이미지만을 저장하는 get_image_fix()라는  함수도  있
다. 이것은 일정한 크기의 이미지를 계속 잡았다가 찍는 작업을 반복할 때 무척 유용하게 쓰인다. 이  함수
를 쓰려면  미리  한번은  get_image()로  이미지를  잡은  다음에  그  포인터를  가지고  이후  반복해서 
get_image_fix()를 쓰면 된다. 물론 메모리의 해제도 마지막에 단 한번 해 주면 된다.
  이미지를 직접 화면에서 얻어 쓸 수도 있지만 디스크에 그 이미지를 저장해 놓는 것도 나쁘지 않다. 라이
브러리에서 쓰는 이미지 화일은 IMG인데 4.0에서도 같은 이름의 화일을 사용했었다. 그러나  4.0에서  쓰던 
형식과 4.1 이상에서 쓰던 형식은 완전히 다른데, 4.0에선 기본적으로 이미지 구조와 동일한 구조의 이미지 
화일을 쓴 반면, 4.1 이상에선 제대로 형식을 갖춘 함수를 쓰고 있다. 이전 버전에서 쓰던 화일은  4.2에서 
사용할 수 없는데, 사용하려면 함께 제공되는 NEW_IMG.EXE라는 프로그램을 이용해서 앞에 헤더를 붙여 주어
야 한다. IMG화일의 헤더는 아래와 같다. number는 저장된 이미지의 갯수를 나타내면 offset[]는 각 이미지
의 오프셋을 뜻한다. 각 이미지의 헤더는 무척 단순하므로 청크는 만들지 않았다. 이미지를 읽는 방법도 기
본적으로는 GPG의 경우와 유사하다. 우선 헤더를 읽어서 몇가지 검사를 한다. 그 다음에 원하는 이미지  번
호와 offset[]을 이용해서 그 이미지가 있는 곳으로 화일 포인터를 이동시킨다. 이제 이미지를  읽기에  앞
서, int형 변수 size_x, size_y두개를 준비해서 그 곳에 각각 2바이트씩 읽어들인다. 그럼  실제  이미지가 
차지하는 크기는 size_x * size_y + 4가 되는 것이다. 이 크기만큼 이미지를 할당하고 그 이미지를  한번에 
읽는다. 그 다음에 화일을 닫으면 끝나는 것이다. 이후 이 이미지는 여타의 다른 이미지와 똑같이 취급하며 
사용이 끝나면 farfree()로 해제해야 한다. 아래 실제 헤더가 있다.

  struct image_header {
             char head_id[15 + 1];
             byte ver;
             byte number;
             dword offset[64];
            };

  실제로 이 작업을 하는 함수는 load_image()이다. 4.1에선 load_lmage_file()라고 했으나 이름에  일관성
을 기하기 위해 4.2에선 이름만 바꾸었다. 이 함수의 형식은 레퍼런스 가이드를 살펴보고, 이런 이미지  화
일을 만드는 프로그램은 함께 포함된 CAP_IMG.EXE를 사용하라. IMGMERGE.EXE를 이용하면 서로 다른  크기의 
여러 이미지를 하나로 합칠 수도 있다. 이제 투명색을 이용한 캐릭터 처리를 알아보자. 캐릭터를 찍는 것은 
다른 이미지를 찍는 것과는 약간 다른 점이 있다. 그대로 이미지를 찍으면 직사각형의  이미지가  찍히지만 
캐릭터는 캐릭터 자체 외에 몸 주위에 해당하는 배경 부분엔 손상을 주어선 안되기 때문이다. 그러므로  캐
릭터를 찍을 때엔 '그림자 패턴(Shadow pattern)'이라는 방법을 쓴다. 그러나 이 방법은 그림자에 해당하는 
이미지를 또하나 만들어야 하고 비트연산을 해서 찍으므로 256색을 전부 사용할 수 있으나, 제작이  번거롭
고 메모리를 많이 차지하며 속도가 느리다는 단점이 있다. 그래서 게임 프로그래밍에선 약간의 편법을 이용
한다. 바로 투명색을 이용하는 것인데, 이미지를 찍을 때 투명색에 해당하는 색은 찍지 않고 그냥 건너뛰는 
것이다. 이렇게 하면 비록 256색중에 한가지 색은 캐릭터를 찍을 때 쓰지 못하지만 대신 빠르고 편하게  캐
릭터를 찍을  수  있다.  이  라이브러리에선  char_put()등의  계열의  이미지  처리  함수  뿐만  아니라 
copy_page_char()등의 페이지 복사 함수에서도 이 방법을 쓰고 있다.  투명색에  해당하는  색은  전역변수 
_attr_null_color에 저장되어 있으며 초기값은 255 (0xFF)이다. 이 라이브러리에선 두가지 경우를 모두  구
현할 수 있다. 기본적인 이미지 찍기 함수인 put_image()가 비트연산이 가능하기 때문이다. 게다가  투명색
을 쓰는 함수는 무척 세분화 되어있고 그 코드도 최적화되어 있어 쓰기에 거의 불편이 없을  것이다.  만약 
이미지를 캐릭터로 찍는데 그 색을 한가지로만  하고  싶으면  char_put_shadow()를  쓰면  된다.  4.1에선 
char_put_shade()라고 썼으나, 4.2에선 char_put_shade()는 약간 쓰임이 다르다. 그러니 4.1에 맞추어져 프
로그래밍 되어 있는 소스를 그대로 4.2에서 컴파일하면 이 부분에서 에러를 내지는 않으나  분명히  엉뚱한 
결과가 나올 것이다. 이제 클리핑에 대해 알아보자. 이미지를 찍을 때 화면을 벋어나면 벋어난 부분이 화면 
어딘가로 다시 나타나는데, 이것의 처리가 힘들다면 클리핑 가능한 함수를 쓰면 된다. 이 클리핑이란  것은 
화면을 벋어나면 짤리는 것을 말한다. 이 클리핑 윈도우는 화면 전체가 아니라도 상관없다. 실제로  클리핑
에 관계하는 전역변수는 _min_x, _min_y, _max_x, _max_y의 네개 변수인데 초기값은 0, 0, 319, 199를 갖고 
있다. 이 변수가 클리핑 윈도우를 결정하는데, 한번에 모두 바꾸고 싶으면  set_clip_window()라는  함수를 
쓰면 된다. 거의 모든 이미지 처리 함수들이 별도의 클리핑 가능한 쌍동이 함수들을 몇개씩  가지고  있다. 
이미지를 저장하는 데이터형은 image_data형이다.  4.1  이하에선  char  *형  데이터를  썼지만  이후로는 
image_data형을 쓰기 바란다. 비록 현재로선 둘 다 차이가 없지만 차후의 버전에선 분명히  차이가  나타날 
지도 모르기 때문이다.


  5) 아이콘 다루기

  아이콘은 4.0에 비해 그 개념이 많이 확장되었다. 4.0의 경우엔 크기가 16x16인 이미지 화일 조각을 아이
콘이라고 했지만 4.1부터는 다수의 크기가 일정한 이미지를 아이콘이라 지칭하게 되었다. 사실상 이제 아이
콘은 이미지와 그 형태면에서 차이가 없어지게 되었다. 그러니 사용자가 적합하다고 생각되는 선에서  아이
콘과 이미지를 구분지어야 한다. 보통 크기가 32x32를 넘어서면 아이콘이라고 하기엔 무리가 있다.  게다가 
모드 13h는 이정도 크기만 해도 무척 큰 크기가 되기 때문이다. 또한 아이콘은 여러개가 함께 무더기로  취
급되는 경우가 많다. 아이콘을 나타내는 데이터형은 icon_data형이다. 그 원형은 game13h.h에 선언되어  있
다.

  typedef struct {
           int number;
           int size_x, size_y;
           image_data *icon;
        } icon_data;

  number은 아이콘의 갯수를 나타내며 size_x, size_y는 그 아이콘의 가로 세로의 크기, 그리고 그  아이콘
들의 실제 데이터가 이미지 데이터의 배열로서 저장되어 있다. 대체로 유틸리티를 만들 때를 제외하고는 이 
데이터형을 직접 제어할 필요가 없을 것이다. 만약 미리 초기화 시켜 아이콘을 사용하려면 위의 데이터형을 
일일히 세트해야 한다. 특히 이미지 부분은 포인터 배열을 다루지 않은 사람에겐 주의를  요하는데  간단히 
매개가 되는 포인터 배열을 하나 선언해서 사용하면 된다. 예를 들어 크기가 16x16인 아이콘 5개를  아이콘 
데이터형으로 선언하고 싶으면,

  image_data temp[5];
  icon_data data;

  data.number = 5;
  data.size_x = data.size_y = 16;
  data.icon = temp;

  아니면 더 간단하게 선언과 동시에 초기화를 해도 좋다.

  image_data temp[5];
  icon_data data = { 5, 16, 16, temp };

  고정된 경우가 아니라 동적으로 아이콘이 생성될 때를 대비해 이러한 구조를 택한 것이다. 아래는 이렇게 
선언된 아이콘 데이터에 실제 이미지 데이터를 넣는 모습이다. 화면에서 잡든 이미 생성된 이미지를 아이콘
으로 만들든 모두 이러한 과정을 거친다.

  data.icon[0] = image1;
  data.icon[1] = image2;
  .
  .
  .

  처음엔 복잡하다고 생각할 지 모르지만 C의 포인터에 대한 이해가 충분히 된 사람은 금방 이해를  할  수 
있을 줄로 안다. 그리고 무엇보다 보통은 이것에 대한 신경을 쓸 필요가 없으니 어려우면 나중으로  미루어
도 된다. 실제로는 디스크에 저장된 아이콘 화일인 ICO화일을 읽어서 쓰는 경우가 많기 때문이다.
  디스크에서 아이콘을 읽는 함수는 load_icon()이다. 이 함수 역시 4.1에선 load_icon_file()였으나 4.2부
터는 load_icon()이라고 바뀌었다. 이 함수는 icon_data형 변수를 인수로 받아들여 한번에 무더기로 아이콘
을 로드한다. 이 함수도 스스로 메모리를 할당하므로 사용이 끝나면 모두 메모리를 해제해야 하는데,  이것
을 편하게 해 주는 함수는 free_icon()이다. 4.1에서의 clear_icon_array()과는 형식이 약간 다르다. 이 함
수는 아이콘 데이터형 포인터를 받아들여 그에 해당하는 포인터가 가리키고 있는 메모리를  전부  해제해준
다. load_icon()은 아이콘의 일부만을 읽어들이는 것도 가능하다.

  struct icon_header {
             char head_id[15 + 1];
             byte ver;
             byte number;
             int size_x, size_y;
            };

  아래의 소스는 "TEST.ICO" 라는 이름의 아이콘 화일을 열어 처음부터 시작해서 아이콘 10개만을 읽어들여 
그것으로 아이콘을 선택하여 그 선택된 번호를 화면에 표시하는 함수이다. 롤 플레잉 등에선 무척 편리하게 
써 먹을 수 있는 함수이다.

  #include <game13h.h>

  #define MAX 10

  main()
  {
    int select;
    icon_data icon;
    palette_256 pal_1[256], pal_2[256];

    init_game13h();
    load_icon( "TEST.ICO", &icon, 0, MAX );

    select = select_icon( icon, MAX );

    make_str_double( 100, 100, str(select), GREEN, NO_DELAY, 1 );
    delay_key();

    free_icon( &icon );
    close_game13h();
  }

  아이콘의 제작은 함께 제공되는 CAP_ICO.EXE와 FEDIT13H.EXE를 이용하면 된다. 하지만 이 두  프로그램은 
모두 16x16 크기의 아이콘만을 지원한다. 그래서 24x24 크기를 지원하는 FEDIT.EXE를 지원하나 여전히 기능
이 미약하다. 차후 확장 예정이다. 또 위의 함수중에 select_icon()이라는 함수도 16x16의 아이콘을 대상으
로 하고 있다. 아직까진 라이브러리의 표준 아이콘 형식은 16x16이다. 마지막으로 4.0에서 쓰던 아이콘  화
일은 4.1 이상에선 사용할 수 없는데, IMG의 경우와 마찬가지로 NEW_ICO.EXE라는 프로그램으로 앞에 헤더를 
붙여주어야 한다.


  6) 팔레트 사용법

  게임이든 타그래픽 프로그램이든 VGA에 있어선 팔레트라는 것이 무척 중요하다. 어차피  256색밖에  쓰지 
못한다면 최대한 적절하게 팔레트를 구성해 놓는 것이 좋고, 게다가 이 팔레트는 잘 이용하면 무척  훌륭한 
효과를 거둘 수 있기 때문이다. 라이브러리의 기본 팔레트는 딜럭스 페인트라는 그래픽 패키지의 기본 팔레
트와 같다. 라이브러리에선 각 색상의 팔레트를 RGB속성으로 변환하는 것이 가능하다. 이때  set_palette()
를 사용하면 된다. 이 RGB속성은 0 ~ 63까지의 64가지 속성을 가질 수 있다. 예를 들어 15번 색깔을  Red속
성을 10, Green속성을 20, Blue속성을 30으로 하고 싶다면,

  set_palette( 15, 10, 20, 30 );

  이라고 호출하면 된다. 라이브러리에서 쓰는 기본 팔레트 구조는 4.1에선 palette_256이었으나 이름의 일
관성을 기하기 위해 4.2부터는 palette_data라고 바뀌었다. 이것은 game13h.h에 다음과 같이  선언되어  있
다.

  typedef struct { char red, green, blue; } palette_data;

  사용에 앞서 palette_data a 라는 식으로 a를 선언하면 이제 a는 a.red, r.green, a.blue로 나누어 쓸 수 
있는 것이다. 라이브러리에선 많은 수의 팔레트 제어 함수를 포함하고 있다. 이 모든 것을 다 일일히  설명
하기는 힘들고, 각각을 시험적으로 사용하면서 그 사용법을 익히는 것이 낫다. 참고로 라이브러리에 전역변
수로 포함된 기본팔레트 배열은 _palette[] 이다. 또한 라이브러리 표준 팔레트 화일인 PAL이 있는데  이에 
대한 설명을 한다. 게임에 따라서는 수많은 팔레트를 이렇게 저렇게 바꾸어야 하는 경우가 많은데 이  경우
에 그 팔레트를 모아서 따로 화일로 관리하는 것이 편하다. 라이브러리에서 지원하는 PAL의 헤더 구조는 다
음과 같다.

  struct palette_header {
             char head_id[15 + 1];
             byte ver;
             byte number;
            };

  우선 헤더인 식별코드가 "Game13h Palette"라 들어 있고, 버전엔 1h값이 들어있으며, number엔 현재 들어
있는 팔레트 정보의 갯수를 기억한다. 개개의 팔레트는 768바이트의 크기를 갖는데, 이것은 256색의 각 RGB
속성을 나타낸다. 팔레트를 읽는 방법은 다음과 같다. 우선 헤더를 읽어들여 몇가지 검사를 한다. 그  다음
에 주어진 인수에 따라 768씩 건너뛴다. 예를 들어 n번째 팔레트를 읽기 원한다면,

  lseek( f, n * 768, SEEK_CUR );  혹은, lseek( f, n * 768 + sizeof( header ), SEEK_SET );

  라는 식으로 화일 포인터를 이동시킨다. 그리고 나서 768바이트를 읽으면 이것이 바로 원하는 팔레트  정
보이다. 실제로 이 작업을 해 주는 함수는 load_palette()이다. 이 함수의 사용법은 레퍼런스 가이드를  참
조하라. 참고로 함께 포함된 LBM2PAL.EXE, PCX2PAL.EXE를 사용하면 특정한 PCX, LBM화일에서 PAL화일을  뽑
아낼 수 있다.


  7) 오버랩 나타내기

  무척 단순하면서도 상당히 멋있는 효과를 낼 수 있는 오버랩도 이 라이브러리는 지원한다.  라이브러리에
서 지원하는 오버랩화일은 GOL로서, Game Over Lab의 약자이다. 이 화일을 만드는 방법은 라이브러리에  함
께 포함된 GPG2GOL.EXE라는 프로그램을 사용하면 된다. 현재 GOL의 버전은 1h이며 단  하나의  RLE이미지와 
두개의 팔레트정보로 이루어져 있다. 현재로선 단순한 4비트 이미지 두개로만 가능하게 되어 있지만 이것은 
어디까지나 GPG2GOL.EXE의 기능이 미약해서이다. 어쨌든 16색으로 그려진 팔레트 포함된 두개의  GPG화일이 
있어야만 제대로 된 GOL화일을 만들 수 있다. GOL화일의 헤더는 다음과 같다.

  struct overlab_header {
             char head_id[15 + 1];
             byte ver;
             word pic_size;
             char rle_flag;
            };

  head_id엔 "Game13h OverLab"라는 내용이 저장되어 있다. 버전은 1h, pic_size는 그림의 크기이며,  이것
은 팔레트와 헤더를 제외한 크기이다. rle_flag는 그림의 압축여부를 나타낸다. GOL을 읽는 과정은  다음과 
같다. 우선 헤더를 읽어서 몇가지 검사를 한다. 그다음에 두개의 팔레트 배열에 각각 768바이트씩 읽어  적
재한다.  그리고 헤더에서 얻은 pic_size를 이용해  그림을  한번에  읽고  이제  화일을  닫는다.  이제는 
rle_flag에 따라 적당히 그림을 디코딩 한 다음에 팔레트 배열 2개를 가지고 오버랩을 구현한다. 실제로 팔
레트 배열 2개를 가지고 부드럽게 서로서로 변하게 하는 함수는 fade_change()이다. 이 fade_change()는 이 
외에도 다른 여러가지 효과를 내는 데에 쓰인다. 오버랩 로드 함수는 load_overlab()이다. 아래 간단한  오
버랩 데모를 보인다.

  #include <game13h.h>

  main()
  {
    palette_data a1[256], a2[256];

    init_game13h();

    set_monitor( OFF );
      load_overlab( "TEST.GOL", 0, a1, a2 );
      change_palette( a1 );
    set_monitor( ON );

    delay_key();
    fade_change( a1, a2, 32, 25 );
    delay_key();
    fade_change( a2, a1, 32, 25 );
    delay_key();

    close_game13h();
  }

  위의 소스는 TEST.GOL이라는 오버랩 화일을 읽어서 두개의 그림 사이를 부드럽게 변형시키며 보여준다. f
모니터를 On/Off 한 것은 오버랩이 화면에 표시되기 전에 팔레트의 변화로 지저분한 모습을 보이지 않게 하
기 위해서이다.


  8) 멀티키 사용법

  원래 이 game13h는 어드밴쳐나 롤플레잉 제작을 목적으로 만들어 졌다. 그래서 액션 게임에는 그다지  적
합하지 않았는데 4.1부터는 액션게임을 목표로 한 다수의 함수가 추가되었다. 대표적인 것은 멀티키를 지원
하는 것인데 이로서 소위 말하는 고감도 키를 구현할 수 있게 되었다. 이 기능은 기본적으로 키보드 인터럽
트 9h를 가로챔으로써 가능한데 이 키보드 인터럽트를 가로채면  그  이전까지  사용을  하던  get_key()나 
action_key()와 같은 버퍼형 입출력 함수는 사용할 수 없게 된다. 원래 버퍼형 입출력 함수는 키보드  인터
럽트 16h를 호출해서 현재 버퍼에 들어 있는 키를 넘겨받는데 멀티 키를 호출하면 버퍼로 키값이  들어가기 
전에 미리 조작을 끝내므로 버퍼엔 데이터가 들어가지 않게 된다. 이런 이유에서 키보드 인터럽트를 가로챈 
다음에 버퍼형 입출력 함수를 호출하면 사실상 그곳에서 프로그램은 다운된 것처럼 보인다. 아무리 키를 눌
러도 반응을 하지 않기 때문이다. 함수는 버퍼에서 계속 데이터를 요구하고, 만약 데이터가 없으면 키를 입
력하기를 기다리는데 키를 입력해봤자 버퍼로는 데이터가 가지 않기 때문에 마냥 기다리고 있기  때문이다. 
이때는 Ctrl + Break나 Ctrl + Alt + Del와 같은 키도 먹히지 않는다. 버퍼로 데이터가 가지 않게 하면  좋
은 점이 있다. 액션 게임에선 어차피 키보드 버퍼는 필요하지 않은 데에다, 버퍼가 꽉차서 컴퓨터가 삑삑거
리며 신호음을 냄으로써 생기는 불쾌한 사태를 피할 수 있다. 멀티키를 위해 실제로 키보드 인터럽트를  가
로채는 함수는  set_multi_key()이고  나중에  다시  원래대로  해  놓는  함수는  reset_multi_key()이다. 
set_multi_key()를 호출한 이후에 전역변수 _key를 살피면 어떤키가 눌렸는지 떼어졌는지 알 수 있다. _key
는 game13h.h에 정의된 구조체이다.

  struct multi_key_data {
    word press;
    byte scan[128];
    byte last;
   };

  struct multi_key_data _key;

  press는 눌린 키의 갯수이도, scan[]의 인덱스는 그 키의 스캔 코드가 된다. 예를 들어 ESC키는 스캔코드
가 1이므로 _key.scan[1]의 값을 살펴서 TRUE면 키가 눌린 것이고 FALSE이면 키를 누르고 있지  않는  것이
다. last는 마지막으로 눌린 키를 나타낸다. 멤버 press를 사용하면 멀티키를 사용하면서  delay_key()처럼 
키가 눌릴 때까지 잠깐 기다리게 할 수 있는데, while( !_key.press ); 라고 해 주면 된다. 스캔코드에  대
한 자료는 비교적 구하기가 쉽지만 참고로 여기 써 놓는다. 이 자료는 가남사의 {IBM-PC 정복}에서  발췌한 
것이다.

     [ 스캔 코드표 ]
  ================================================================================================

                                          >> 일 반 키 <<

           '  ' - 2                         '  ' - 20                        '  ' - 38     
           '  ' - 3                         '  ' - 21                        '  ' - 39     
           '  ' - 4                         '  ' - 22                        '  ' - 40     
           '  ' - 5                         '  ' - 23                        '  ' - 41     
           '  ' - 6                         '  ' - 24                        '  ' - 43     
           '  ' - 7                         '  ' - 25                        '  ' - 44     
           '  ' - 8                         '  ' - 26                        '  ' - 45     
           '  ' - 9                         '  ' - 27                        '  ' - 46     
           '  ' - 10                        '  ' - 30                        '  ' - 47     
           '  ' - 11                        '  ' - 31                        '  ' - 48     
           '  ' - 12                        '  ' - 32                        '  ' - 49     
           '  ' - 13                        '  ' - 33                        '  ' - 50     
           '  ' - 16                        '  ' - 34                        '  ' - 51     
           '  ' - 17                        '  ' - 35                        '  ' - 52     
           '  ' - 18                        '  ' - 36                        '  ' - 53     
           '  ' - 19                        '  ' - 37                   Space bar - 57


                                          >> 콘트롤 키 <<

            Esc - 1                         Ctrl - 29                         Alt - 56
     Back Space - 14                  Left Shift - 42                   Caps Lock - 58
            Tab - 15                 Right Shift - 54                    Num Lock - 69
          Enter - 28                      PrtScr - 55                 Scroll Lock - 70


                                           >> 펑션 키 <<

             F1 - 59                          F5 - 63                          F9 - 67
             F2 - 60                          F6 - 64                         F10 - 68
             F3 - 61                          F7 - 65                         F11 - ?
             F4 - 62                          F8 - 66                         F12 - ?

                                          >> 키패드 키 <<

           Home - 71                        '  ' - 76                   Page Down - 81
           '  ' - 72                        '  ' - 77                         Ins - 82
        Page Up - 73                        '  ' - 78                         Del - 83
           '  ' - 74                         End - 79                     Sys Req - 67
           '  ' - 75                        '  ' - 80

  ================================================================================================


  9) 페이지 사용법

  통상 모드 13h는 페이지 플립이 안되는 것으로 알려져 있다. 레지스터를 조작하여 소위 플레인  모드라는 
것으로 바꾸면 그것이 가능하기는 하지만 호환성과 속도면에서 문제가 있다. 비록 플레인 모드엔  표준모드
에서 지원하지 않는 수많은 장점이 있지만 표준을 지향하는 사람은 과감히 포기할 수밖에 없다. 그래서  도
입한 것이 더블 버퍼링이다. 이것은 페이지 플립만큼은 아니지만 상당히 빠른 속도를 낼 수 있다. 무엇보다 
연속된 메모리로 이미지를 다룰 수 있기 때문에 페이지 플립보다 주소계산이나 이미지 조작이 쉽고  빠르다
는 장점이 있다. 더블 버퍼링은 비디오램과 같은 량의 메모리를 하나의 페이지처럼 처리해서 화면에 표시하
고 비디오램으로 복사하는 것이다. 이것을 위해 이 라이브러리는 _screen_page[]라는 배열과  _page_number
이라는 변수를 준비해 두고 있다. _screen_page[]는 각 페이지의 시작 포인터의 세그먼트 번지를  저장하고 
있고, _page_number은 지금 쓰고 있는 페이지의 번호를 저장하고 있다. 사용하는 페이지를  바꾸고  싶으면 
_page_number라는 변수를 바꾸면 된다. _page_number가 0일 때엔 직접 화면상에 작업을 하는 것이다.  불편
한 것이라면 페이지 플립과 쓰는 방법이 조금 다르다는 것 정도와 페이지를 쓰는만큼 사용가능한  메모리가 
줄어든다는 것이다. 그래서 비디오램을 포함한 3개의 페이지만을 준비해 두었다. 페이지를 쓰기 위해선  먼
저 init_page()라는 함수를 호출해야 하며, 쓸모가 없어지면 close_page()라는 함수를 호출해야 한다. 다음 
프로그램은 페이지를 한개 추가하여 1페이지에 그림을 로드한 후 그것을 화면에 표시하는 프로그램이다.

  #include <game13h.h>

  main()
  {
    init_game13h();
    init_page( 1 );

    _page_number = 1;
    load_picture( "PICTURE.GPG", 0 );
    get_key();

    activity_page( 1 );
    delay_key();

    close_page();
    close_game13h();
  }

  프로그램에서 activity_page()라는 함수는 페이지를 활성화 시키는 함수이다. 즉, 1페이지에서 작업을 한 
후 이 함수로 실제 화면으로 옮기는 것이다. 페이지 플립과 달라서 약간의 지연이 있다는 것과  비디오램의 
정보는 지워진다는 단점이 있다. 이것과 함께 copy_page()라는 함수가 있는데 이것은 페이지끼리  복사하는 
함수이다. 이것을 이용하면 activity_page()와 동일한 효과를 얻을 수 있으나 알아보기 편하게  하기  위해 
그냥 그대로 두었다. activity_page()함수를 사용하면 자동적으로 작업페이지가 0으로 된다. 4.1에  도입되
었던 스크린 버퍼는 호환성 문제 때문에 4.2부터는 삭제되었다.


  10) *.VOC화일 제어법

  버전 4.0부터 추가된 기능중에 하나가 바로 Sound BLASTER에서 제공되는 표준 보이스  화일인  VOC화일을 
지원하게 되었다는 것이다. 4.0에서는 타이머를 이용해서 보이스를 출력했으나 4.1부터는  DMA를  이용하게 
되었다. 이것에 있었던 약간의 버그도 4.2에선 말끔히 제거되었다. 이 보이스 화일은 비교적 구조가 간단하
고 처리가 간단하여 쉽게 프로그램에 포함시킬 수 있다. 먼저 보이스 화일을 출력하기 앞서 사운드  디바이
스를 세트해야 한다. 이것을 위해 NO_VOICE, PC_SPEAKER, S_BLASTER등 몇가지 타입이 정의되어 있으니 헤더
를 보고 참고하기 바란다. 그냥 init_voice()에 이 값을 넣기고 초기화 시키기만 하면 된다. 그리고  VOC화
일을 읽어들인 후 필요할 때 출력하면 된다. 단, 이 함수들은 모두 farmalloc()함수를 이용해 동적으로  할
당된 메모리를 사용하니, 필요가 없어지면 free_voice()로 제거하기 바란다. 아래의  예제는  TEST.VOC라는 
화일을 읽어들여서 출력하는 함수이다.

  #include <game13h.h>

  main()
  {
    voice_data voc_data;

    init_voice( S_BLASTER );
    read_voc_file( "TEST.VOC", &voc_data );

    output_voice( voc_data );

    free_voice( &voc_data );
    close_voice();
  }  

  보이스 제어모듈은 4.1부터 DMA를 제어하는 것이 가능하도록 만들어졌다. PC스피커는 여전히  CMOS인터럽
트를 이용했기 때문에 속도가 조금 느리다. 사블의 경우엔 기본적으로 기본 입출력 주소와 IRQ 번호,  그리
고 DMA 채널을 정확히 맞추어 주어야 원하는 결과를 얻을 수 있는데, 이를 위해 자신의 사운드 카드의 사양 
상태를 정확히 알아 두어야 한다. 이를 위해 준비된  변수가  _sb인데,  이  변수는  아래와  같은  구조체 
sb_state로 정의되어 있다.

  struct sb_state {
            int  io_addr;
            byte irq;
            byte dma_channel;
          };

  정확한 값을 알았다면 _sb.io_addr, _sb.irq, _sb.dma_channel의 전역변수를 세트해야 한다. 각각 0x220, 
7, 1로 초기값이 주어져 있으니, 필요하면 이 변수를 바꾸는 일만 하면 된다. 또한 샘플링 주파수가 초기엔 
8000 ( 8kHz )로 되어 있으니 이것도 원한다면 바꾸어도 된다. 숫자가 크면 클수록 보이스 출력 속도가  빨
라진다.


  11) Mouse 사용법

  4.0부터 제공되던 마우스는 4.2에 와서 획기적으로 바뀌게 되었다. 4.0에서 제공하던 마우스 모듈은 그야
말로 기본적인 기능만이 제공되었으나 4.2에선 그 사용법이나 기능면에서 훨등히 향상되었다. 마우스를  위
해 제공된 전역변수는 _mouse이며, 여기엔 마우스의 현재 상태에 대한  모든  정보가  들어있다.  _mouse는 
mouse_point_data라는 구조체의 형태로 되어 있는데 그 원형이 아래에 있다.

  struct mouse_point_data {
    int  x, y;
    bool display_cursor;
    int  double_click_speed;
    bool move;
    bool left;
    bool right;
    bool double_click;
    bool drag;
  };

  x, y는 각각 마우스 커서의 x, y 좌표, display_cursor는 커서가 화면에 나타나 있는가의 여부를  나타내
며, move, left, right, double_click, drag는 모두 마우스의 상태에 따라 TRUE 혹은 FALSE의 값으로  세트
된다. 무엇보다 4.2에서의 마우스 모듈은 사용자 이벤트 핸들러가 다양하게 지원된다는 데에 장점이  있다. 
이 이벤트 핸들러는 잘만 사용하면 더할나위 없이 편리한 마우스를 사용할 수 있도록 해 줄 것이다.

  #define MOUSE_MOVE    0
  #define LEFT_CLICK    1
  #define RIGHT_CLICK   2
  #define DOUBLE_CLICK  3
  #define ALL_CLICK     4
  #define MOUSE_DRAG    5

  void (*_user_handle[6])( void );

  이 핸들러를 사용하기 위해선 우선 마우스가 초기화 되어 있어야 한다. 그리고 각각의 이벤트에 맞는  함
수를 선언해 놓아야 한다. 예를 들어 마우스가 마우스가 움직일 때마다 화면의 상단에 현재의 마우  커서의 
좌표를 표시하게 하고 싶다면 간단히 아래의 예를 응용하면 될 것이다.

  #include <game13h.h>

  void display_mouse_position()
  {
    mouse_cursor_off();
    bar( 0, 0, 73, 15, LIGHTBLUE );
    make_str_double(  0, 0, str(_mouse.x), WHITE, 2 );
    make_str_double( 32, 0, ",", WHITE, 2 );
    make_str_double( 48, 0, str(_mouse.y), WHITE, 2 );
    mouse_cursor_on();
  }

  main()
  {
    init_game13h();
    init_mouse();

    clear_screen( LIGHTBLUE );
    mouse_cursor_on();
    _user_handle[ MOUSE_MOVE ] = display_mouse_position;

    while( !_mouse.double_click );

    close_mouse();
    close_game13h();
  }

  이 프로그램은 마우스 버튼을 더블클릭하기 전까지 마우스의 움직임에 반응하여 계속해서 마우스  커서의 
좌표를 화면에 표시한다. 원한다면 동시에 여러개의 이벤트를 설정해 놓을 수 있다. 결과적으로 이  방법은 
복잡한 마우스 제어에 머리가 아픈 사람에게 큰 도움을 줄 것이다.
  내장된 마우스 커서는 16x16의 커서이다. 원한다면 언제든 마우스 커서를 교체할 수가  있다.  4.2에서의 
마우스 모듈은 4.1의 경우와는 달리 16x16의 비트맵 이미지가 아니라 256컬러의 이미지가 마우스 커서가 된
다. 즉 컬러 마우스 커서를 지원하는 것이다. 이 때문에 마우스 모듈이 조금 커지기는 했지만 이로 인해 훨
씬 세련된 마우스 커서를 사용할 수 있게 되었다. 혹시나 더 느려지지 않을까 염려하는 사람이 있다면 안심
해도 된다. 테스트 해 본 바에 의하면 속도면에선 거의 차이가 없었다.


  12) Button 이용 방법

  4.2부터는 흔히 사용되나 구현하기가 조금 번거로운 버튼을 편리하게 구현해 준다. 이것은 OOP에서  힌트
를 얻어서 추가한 것이지만 C의 특성상 제대로 구현해 낼 수가 없었다. 그러나 그 형태면에선 유사한  점이 
있으니 C++을 쓰시는 분들은 그 형태면에서 어느정도 만족을 얻을 수 있을 것이다.
  버튼을 나타내는 데이터형은 button_data형이다. 이 데이터는 버튼의 크기와 그 눌림 여부를 판단하는 데
이터를 함께 가지고 있다.

  typedef struct {
            int start_x, start_y;
            int end_x, end_y;
            bool push_flag;
           } button_data;

  앞의 int형 변수 4개는 버튼의 크기를 나타낸 것이다. 그리고 push_flag는 현재 버튼이 눌린 상태인지 아
닌지를 표시한다. 아래에 간단한 버튼 사용의 예를 보인다.

  #include <game13h.h>

  main()
  {
    button_data button;

    init_game13h();
    draw_button( 10, 10, 50, 50, &button );

    delay_key();
    push_button( &button );
    delay_key();
    release_button( &button );
    delay_key();

    close_game13h();
  }

  이 버튼 데이터는 특별히 메모리같은 것을 할당하지 않기 때문에 나중에 해제시키는 과정이  필요  없다. 
이 버튼 데이터 형은 마우스의 check_mouse()함수와 병합하여 사용하면 좋은 결과를 얻을  수  있다.  만약 
button_data형으로 b가 선언되어 생성되었다면, check_mouse( b.start_x, b.start_y, b.end_x, b.end_y )로
써 마우스 커서가 현재 그 버튼 위에 있는지 아닌지를 알 수 있다.


  13) MDI화일 연주

  Adlib호환 카드가 있다면 게임에 음악을 넣을 수가 있다. 음악 루틴은 Adlib 툴킷에서 많은 부분을  옮겨
왔기 때문에 독자적인 프로그램이라고 할 수는 없지만 사용에 편리하게 많은 부분을  수정했으므로  사용에 
별 무리가 없을 것이라는 것은 보장한다. 직접 포트를 제어했기 때문에 SOUND.COM이 필요없고 속도도  빠른 
편이다. 음악을 연주하기 위해서는 먼저 음악카드를 초기화 시키고 음악화일을 로드한 다음 연주를  시작하
면 된다. 음악을 중지시키기 위해서는 stop_music()을 쓰면 된다. 4.1에 있던 stop_melody()는 약간 수정되
면서 stop_melody()로 이름이 바뀌었다. 가로챈 인터럽트를 돌려주기 위해 close_midi()라는 함수를 마지막
으로 호출해준다. 아래에 간단한 연주의 예가 있다.

  #include <game13h.h>

  main()
  {
    init_midi();

    play_midi( "TEST.MDI" );
    delay_key();
    stop_melody();

    close_midi();
  }

  하나 주의할 것은 음악을 연주하다가 다른 음악으로 바꾸고 싶으면 먼저 stop_music()함수를 호출해 줘야 
한다는 것이다. 음악을 연주하기 위해 잡아놓은 메모리를 반납해야 하기 때문이다. 음악이 끝났는가를 살피
려면 전역변수 _playing_flag를 살피면 된다. 이 플랙이 TRUE이면 연주중이고 FALSE면 연주가 끝난 것이다.


  14) XMS 제어 방법

  게임이라는 것이 원래 메모리를 많이 요구하기 때문에 추가의 메모리가 필수적으로 요구된다. 그래서 4.2
부터는 XMS는 그 특성상 직접 제어가 불가능하다. 그러므로 일종의 데이터 보관용 버퍼로밖에 쓸 수 없는데 
이것을 잘 활용하면 메모리 절약에 큰 도움이 된다. 우선 제작자가 오버레이에 대한 지식이 부족한  관계로 
프로그램을 이 XMS로 올리는 것은 지원하지 않는다. 대신 사용자가 쓰는 각종 데이터들을 이곳으로  옮기고 
당장 쓸 데이터들만을 기본 메모리에서 사용하면 훨씬 풍족한 메모리를 사용할 수 있을 것이다. 아마  다음 
버전에선 오버레이를 지원하고 이 XMS를 직접 제어하는 루틴을 포함할 수 있을 것이다(공부중이니까...).
  XMS는 직접 제어가 되지 않는 대신에 XMM이라는 확장 메모리 관리자에게 필요한 기능을 전달하고, 그  정
보가 되는 핸들만을 전달하면 원하는 기능이 수행되는 형태로 제어를 한다. XMM은 대표적으로  HIMEM.SYS가 
있고 QEMM의 경우엔 HIMEM.SYS 없이도 사용 가능하다. 먼저 xms_install()을 실행하면 필요한 초기화를  하
고 그 결과값을 리턴한다. 만약 1이 리턴되면 XMM이 설치되지 않은 것이다. 이 경우 XMS제어 모듈의 사용이 
불가능하다.
  XMS에 메모리를 할당하는 함수는 xms_alloc()이다. 할당에 앞서 xms_size()를 실행하면 현재 남은 총 XMS
의 사이즈와 한번에 할당할 수 있는 최대크기의 XMS에 관한 정보를 얻을 수 있다. 실행 전에 이것을 넉넉한 
XMS가 있나를 확인해 보고 그렇지 않으면 프로그램을 중단시키는 경우에 유용하다. xms_alloc()는 그  인수
로 할당하고자 하는 XMS의 크기를 KB단위로 준다. 즉, 할당하고자 하는 XMS가 1024라면 인수는 1을 주는 것
이다. 만약 필요한 메모리가 1025라도 인수는 2를 주어야 한다. 필요한 메모리를 할당하면  그  리턴값으로 
마치 화일의 핸들을 넘겨주듯이 이것도 핸들을 리턴한다. 앞으로 이 핸들은 메모리를 저장하거나 꺼낼  때, 
XMS를 해제할 때 등에 사용된다. XMS에 메모리를 저장하려면 xms_push()를 사용한다. xms_push()의  인수는 
핸들과, 저장하고자 하는 데이터의 포인터, 그리고 그 크기이다. 물론 이 크기는 Byte단위이다. XMS에서 데
이터를 꺼내오는 것은 xms_pop()이다. 형식은 비슷하다. 만약 XMS가 더 이상 필요가 없어진다면 xms_free()
를 써서 해제하면 된다. 하지만 실제로 이 함수들을 사용하기 보다는 store_screen()이나  store_image()등
을 이용해서 사용한다. store_screen()은 원하는 페이지의 그림을 XMS로 옮기는 함수이다. 다시 꺼내올  때
는 restore_screen()을 사용한다. store_image()는 현재 사용하고 있는 이미지 데이터를 XMS로 옮긴다. 단, 
이렇게 이미지를 옮길 경우엔 현재 사용하고 있던 이미지는 사라진다. 내부적으로 farfree()를 사용하기 때
문이다. 역시 restore_image()는  이미지를  꺼내지만  이  경우엔  내부적으로  할당된  XMS를  해제한다. 
restore_screen()이 몇번이고 반복해서 그림을 XMS에서 불러올 수 있는 것에 반해 restore_image()는 단 한
번밖에 불러올 수가 없다. 제작자가  사용을  해  본  결과  가장  빈도수가  높은  경우를  택한  것이다. 
restore_image()는 대신 이미지가 저장될 메모리를 farmalloc()로 스스로 할당한다.  그러므로  이경우에도 
get_image()계열의 함수들처럼 사용이 필요 없어지면 farfree()로 해제해야 한다.


  15) 각종 유틸리티 함수의 사용법

  프로그램을 짜면서 상당히 자주 쓰이는 자질구레한 함수가 있을 것이다. 이런 함수들을 일일히 만들어 쓰
는 것은 그다지 어려운 일은 아니겠으나 상당히 귀찮은 일임에 사실이다. 이런 기능을 갖는 함수들을 이 라
이브러리에선 일부 제공한다. 이런 유틸리티들은 모두 util이라는 모듈에서 제공하는데 라이브러리의  헤더
를 보면 대충 몇가지 있는가를 알 수 있다. 우선 편리하면서도 쉽게 쓸 수 있는 함수중 gen_menu()라는  함
수만을 예로 들어 설명한다. 나머진 쉽게 쓸 수 있으니 레퍼런스 가이드를 보시라. 아래는 메뉴를 호출하여 
선택한 항목의 번호를 표시하는 함수이다.

  #include <game13h.h>

  main()
  {
    int select;
    char *message[3] = { "밥", "떡", "빵", "엿" };

    init_game13h();
    read_font( H_GT, E_GT, "" );

    select = gen_menu( message, 4, 3 );
    make_str( 0, 0, str( select ), LIGHTBLUE, NO_DELAY );
    get_key();

    close_game13h();
  }

  4.2 부터는 4x6의 작은 폰트를 제공하기 때문에 더 많은 문자를 화면에 표시할 수 있다. 이 폰트를  이용
해서 출력하는 함수는 make_str_small()이며 이에 맞는 메뉴 제네레이터는 gen_menu_small()이다.  단,  이 
폰트는 한글을 지원하지 않는다.
  이외에도 편리하게 쓸 수 있는 함수는 많다. 예를 들어 get_exec_path()의 경우엔 4.1의 get_path()를 수
정한 것인데 기능이 더 보강되었다. 또한 str()이나 str_hex()는 스트링 계열의 함수에 섞어서 쓰면 편리하
고, reply_quit(), yes_or_no()같은 함수도 상당히 자주 쓰이나 무척 쉽기 때문에 굳이 예를  들지  않아도 
레퍼런스 가이드를 보면 알 수 있다.



  3) 유틸리티 화일

  라이브러리 4.2에는 몇가지 유틸리티가 함께 들어있다. 그 목록은 아래와 같다. 거의 대부분이  컴파일이 
되지 않았는데 손쉽게 컴파일 해서 이용할 수 있으므로 걱정할 필요는 없다. 물론  거의  모두가  컴파일시 
GAME13H.LIB를 필요로 한다. 차례대로 다음과 같다.

  bioskey.c        - 눌려진 키의 스캔코드와 아스키 코드를 나타낸다. 바이오스 인터럽트를 사용한다.
  cap_ico.c        - GPG화일에서 ICO화일을 잡아낸다.
  cap_img.c        - GPG화일에서 IMG화일을 잡아낸다.
  cut_img.c        - GPG화일에서 투명색을 제외한 사각의 이미지를 추출한다. 상당히 유용하다.
  dat2gpg.c        - 4.0이전의 버전에서 쓰던 DAT화일을 GPG화일로 변환한다.
  fedit13h.c       - ICO화일을 만들거나 편집한다.
  fedit13h.gpg     - FEDIT13H의 화면 데이터
  gpg2gol.c        - GPG화일 두개를 이어서 GOL화일을 만든다.
  gpgmerge.c       - GPG화일을 연결한다.
  ico2win.c        - 9개의 16x16크기를 갖는 아이콘화일을 WIN화일로 변환한다.
  imgmerge.c       - IMG화일을 연결한다.
  key.c            - 눌려진 키를 Game13h에서 사용하는 형식으로 출력한다.
  lbm2gpg.c        - LBM화일을 GPG화일로 바꾼다.
  lbm2pal.c        - LBM화일에서 팔레트 정보를 떼어내 PAL을 만든다.
  pcx2gpg.c        - PCX화일을 GPG화일로 바꾼다.
  pcx2pal.c        - PCX화일에서 팔레트 정보를 떼어내 PAL을 만든다.
  new_ico.c        - 구버전의 ICO를 신버전으로 업그레이드
  new_img.c        - 구버전의 IMG를 신버전으로 업그레이드
  new_pal.c        - 구버전의 PAL을 신버전으로 업그레이드
  pcx2gpg.c        - PCX화일을 GPG화일로 바꾼다.
  pcx2pal.c        - PCX화일에서 팔레트 정보를 떼어내 PAL을 만든다.
  viewgol.c        - GOL화일을 본다.
  viewgpg.c        - GPG화일을 본다.
  viewimg.c        - IMG화일을 본다.
  viewpal.c        - PAL화일을 본다.
  viewwin.c        - WIN화일을 본다.
  patch.com        - TC.EXE혹은 BC.EXE를 라이브러리에 맞게 패치한다.
  unpatch.com      - patch.com에 의해 바뀐 것을 원래대로 해 놓는다.
  rol2mdi.exe      - ROL화일을 MDI화일로 바꾼다.

  이 유틸리티들을 잘 활용하는 것이 라이브러리 활용의 지름길이다. 비록 최소한의 기능만을 가지고  있는 
주먹구구식의 유틸리티이지만 처음 라이브러리를 접했을 때엔 이것이라도 있어야 어느 정도 활용이  가능하
다. 소스가 공개되어 있으니 누구든지 더 나은 툴 제작을 위해 참고하기 바란다. 개인적으론 툴 제작에  서
툴기 때문에 누구든지 이 유틸리티보다 성능이 향상된 새로운 제작 툴을 개발하여 보내주신다면 무척  고맙
게 여길 것이다. 이 유틸리티들을 MDIR과 같은 쉘을 이용해서 사용한다면 무척 편리한 환경을 구성할 수 있
을 것이다.



  * 끝으로...

  이 라이브러리는 제가 쓰기 위해서 만들었지, 라이브러리 자체를 공개하기  위해  만든  것은  아닙니다. 
(4.1부터는 달라졌지만...) 그러므로 이 라이브러리엔 제작자의 평소 프로그래밍 환경이 많이 반영되어  있
습니다. 저는 주로 딜럭스 페인트를 이용해서 게임을 만드는데, 이런 이유로 인해서 이 라이브러리엔  딜럭
스 페인트에 맞춘 함수들이 많이 존재합니다. 대표적으로 초기 팔레트 배열이 딜럭스 페인트에 맞추어져 있
는 것 등입니다. 사실 딜럭스 페인트는 무척 우수한 에디터이고 그 팔레트의 구성도 상당히 잘 되어 있으므
로 여지껏 게임을 만들면서 이 팔레트를 바꿀 필요성을 별로 느끼지 못했습니다. 꼭 팔레트를 바꿀  필요가 
있는 사람은 set_palette()함수를 이용하든가 아니면 load_palette()라는 함수를 이용하면 됩니다. 이 함수
의 데이터가 되는 함수는 별도로 제공되는 유틸리티인 LBM2PAL.EXE나 PCX2PAL.EXE를 사용하십시요.

  이 라이브러리는 단순히 게임을 만들기 위해 만들었다는 것을 잊지 마십시요 그러므로  일반적인  그래픽 
라이브러리와 혼동해선 안됩니다. 여긴엔 곡선을 그리는 함수도, 색칠하는 함수도 없다.  대신  디스크에서 
그림을 로드하는 함수, 그래픽 모드에서 스트링을 입력받는 함수, 팔레트를 로드하는 함수등이 구비되어 있
습니다. 그런 것은 모두 레퍼런스 가이드에 설명되는 것을 참고하기 바랍니다. 또한 저의 습관에 따라 사용
자를 혼동시키는 여러가지 부분이 있는데 금방 익숙해 지리라 믿습니다. 본인은 프로그램을 짤 때에 대소문
자를 섞어 쓰지 않습니다. 그러므로 모든 함수의 이름이 소문자로만 되어 있죠. 또 매크로 함수라도 함수의 
형태를 갖고 있으면 그냥 소문자로 써 버렸습니다. 이점 주의하기 바란다. 마지막으로  훌륭한  국산게임을 
만들기 위해 노력하는 분들께 격려를 보내며 이 라이브러리를 사용하시는 분들께서 나중에  이러한  대열에 
끼어 국산게임의 발전에 이바지할 수 있기를 빕니다.



                                >>> 감사합니다 <<<
