 

                          모드 13h 전용 라이브러리
                                       (게임 제작용 버전 4.2)
                           >>> 레퍼런스 가이드 <<<

                                                                    제작자 : 주 경 민 





  1) GAME13H.H 가이드

  본 라이브러리는 GAME13H.H와 GAME13H.LIB라는 두 화일로 구성되어 있다. 그 외에 폰트 화일이나  유틸리
티 화일들은  유저  가이드에서  설명을  한다.  여기서는  라이브러리에  쓰이는  데이터형이나  구조체등 
GAME13H.H의 내용을 설명한다. 라이브러리 헤더의 첫부분은 컴파일 시 메모리 모델을 검색하는  역할을  한
다. 그래서 만약 메모리 모델이 LARGE나 HUGE가 아니라면 컴파일을 중지한다. 다음은 라이브러리  헤더에서 
이미 인클루드하는 표준 헤더 화일이다.

       <dos.h>, <stdio.h>, <stdlib.h>, <string.h>, <alloc.h>, <io.h>, <fcntl.h>

  다음은 라이브러리 내부적으로 참조하는 매크로 상수들이며 프로그래머들을 위해서도 일부 제공된다.

  #define GRAPH_SEG   0xA000      ... 비디오램의 시작 세그먼트 번지
  #define H_RES       320         ... 수평 해상도
  #define V_RES       200         ... 수직 해상도
  #define MAX_X       319         ... 실제 최대 x좌표
  #define MAX_Y       199         ... 실제 최대 y좌표
  #define NO_SKIP     0           ... 디스크 입출력시 스킵하는 크기를 0으로 한다.
  #define NO_DELAY    0           ... 각종 딜레이를 쓰는 함수에서 딜레이 타임을 0으로 한다.
  #define NULL_COLOR  255         ... 캐릭터 관련 함수의 기본 투명색.

  #define TRUE        1           ... C의 True 로직 값
  #define FALSE       0           ... C의 False 로직 값
  #define CANCEL     -1           ... 유틸리티 함수에서 사용하는 리턴값
  #define ON          TRUE        ... On 로직
  #define OFF         FALSE       ... Off 로직

  다음은 라이브러리의 기본 16색의 상수이며 이것은 VIDEO MASTER ROM의 기본 색과도 일치한다. GAME13H.H
에는 Turbo-C의 CONIO.H와 중복되지 않도록 몇가지 배려를 하고 있다.

  enum {
      BLACK,    BLUE,      GREEN,      CYAN,      RED,      MAGENTA,      BROWN,  LIGHTGRAY,
      DARKGRAY, LIGHTBLUE, LIGHTGREEN, LIGHTCYAN, LIGHTRED, LIGHTMAGENTA, YELLOW, WHITE
     };

  다음은 get_key()나 action_key()에서 사용하는 키값으로 사용 빈도수가 높은 몇개만을 매크로 상수로 정
해 놓았다. 여기서 2자리 숫자는 아스키 값을 갖는 키값이며 4자리 16진수 숫자는 스캔코드만을 갖는  키값
이다. 별도로 제공되는 KEY.COM이라는 프로그램을 이용해서 원하는 키의 키값을 알아볼 수 있다.

  #define ESC             0x1B
  #define SPACE           0x20
  #define ENTER           0x0D
  #define TAB             0x09
  #define UP_LEFT         0x4700
  #define UP              0x4800
  #define UP_RIGHT        0x4900
  #define LEFT            0x4B00
  #define RIGHT           0x4D00
  #define DOWN_LEFT       0x4F00
  #define DOWN            0x5000
  #define DOWN_RIGHT      0x5100
  #define ALT_X           0x2D00
  #define F1              0x3B00
  #define F10             0x4400
  #define PG_UP           UP_RIGHT
  #define PG_DN           DOWN_RIGHT
  #define HOME            UP_LEFT
  #define END             DOWN_LEFT

  라이브러리 뿐만 아니라 다른 곳에서도 널리 쓰이는 데이터형이다. 모두 unsigned형을 지정한 것인데  사
용 빈도수가 매우 높은 것이다.

  typedef unsigned char byte;
  typedef unsigned int  word;
  typedef unsigned long dword;
  typedef int           bool;

  다음은 주요 데이터형들이다. 모두 구조체로 되어 있으며, 라이브러리 사용에 도움이 될 것이다.

  . 아이콘 데이터 형
  typedef struct {
           int number;
           int size_x, size_y;
           image_data *icon;
        } icon_data;

  . 이미지 데이터 형
  typedef char* image_data;

  . 윈도우 데이터 형
  typedef struct {
           int x, y;
           image_data image;
          } window_data;

  . 팔레트 데이터 형
  typedef struct { char red, green, blue; } palette_data;

  . 버튼 데이터 형
  typedef struct {
            int start_x, start_y;
            int end_x, end_y;
            bool push_flag;
           } button_data;

  그 외에 따로따로 define된 상수들은 모두 각각 모듈 의존성이 강한 것들이라 설명에서 제외했다. 이러한 
것들은 모두 User's Guide를 참고하기 바란다. 또, 라이브러리의 컴파일은 80186/80286 모드에서 컴파일 해
야만 한다. 라이브러리의 코드들이 286에 맞도로 최적화 되었기 때문이다. 메모리 모드는 Large 이상이어야
만 한다. 그렇지 않으면 컴파일 시 에러를 낸다. 마지막으로 함수의 이름 선정 규칙을 적는다.

  1. 어떤 장치를 초기화 할 때엔 'init_...' 로 시작된 함수를 쓰며, 그것을 해제할  때엔  'close_...'의 
    이름을 가진 함수를 사용한다.
  2. 디스크에서 화일을 로드하는 것은 'load_...'의 함수를 사용한다.
  3. 동적으로 할당된 메모리 해제에 관계된 전용 함수는 'free_...'의 함수이다.
  4. 특정한 작업을 시작할 때엔 'set_...'로 시작하며 마칠 때엔 'reset_...'의 함수를 쓴다.
  5. 함수중에 계통적으로 하위에 속한 함수는 상위 함수의 뒤에 추가명을 붙이는 형태로 되어 있다.  예를 
    들어   char_put()의   하위   함수인   char_put_shadow(),   그것의   기능이     확장된     함수는 
    char_put_shadow_clip()등이다.
  6. 사용자가 접근하기 쉬운 전역변수는 앞에 '_'를 붙인다.
  7. 함수의 내부에서 함수 외부의 값을 바꿀 때엔 반드시 Call by Reference를 이용한다.
  8. 대부분의 함수가 성공적인 경우엔 0을, 그렇지 않은 경우엔 에러값을 리턴하도록 디자인 되어 있다.



  2) 주요 전역변수

-------------------------------
   byte _attr_shadow_color 
-------------------------------
  char_put_shadow()등의 함수를 써서 그림자를 찍을 때 입체감을 나타내는 그림자가 되는 색이다.  디폴트
는 BLACK이다.

-------------------------------
   byte _attr_back_color
-------------------------------
  scroll_clear()등의 함수에서 쓰이는 배경색이다. 디폴트는 BLACK이다.

-------------------------------
   byte _attr_null_color
-------------------------------
  char_put()등에서 쓰는 투명색이다. 디폴트는 NULL_COLOR (255)이다.

-------------------------------
    word _delay_message
-------------------------------
  문자열 출력 함수에서 그 지연 시간을 나타내는 변수. 초기값은 NO_DELAY (0) 이다.

-------------------------------
 int _min_x, _max_x, _min_y, _max_y
-------------------------------
  클리핑 윈도우를 구성하는 좌표들이다. 디폴트는 각각 0, 0, 319, 199이다.

-------------------------------
  struct multi_key_data _key
-------------------------------
  현재의 키 상태를 기억하고 있다. 이 변수는 set_multi_key()함수가 호출된 다음에야 효과를 갖는다.  자
세한 것은 User's Guide를 참조하라.

-------------------------------
 word _hangul1[6][19][16],
      _hangul2[2][21][16],
      _hangul3[28][16]
 byte _english[94][16]
 byte _special[14][16]
-------------------------------
  폰트 데이터를 저장하고 있다.

-------------------------------
 struct mouse_point_data _mouse
-------------------------------
  마우스의 상태에 대한 데이터를 담고 있다. 자세한 사용법은 User's Guide를 참조하라.

-------------------------------
 void (*_user_handle[6])( void )
-------------------------------
  마우스 사용자 이벤트 핸들들을 저장한 함수 포인터 배열.

-------------------------------
    byte _last_page_number
-------------------------------
  마지막 페이지 번호를 기억하고 있는 변수. 디폴트는 0이다.

-------------------------------
     byte _page_number
-------------------------------
  현재의 페이지 번호를 기억하고 있다. 페이지를 바꾸려면 단순히 이 변수에 원하는 페이지를 세트해 주면 
된다. 디폴트는 0이다.

-------------------------------
    word _screen_page[4]
-------------------------------
  현재 사용하고 있는 페이지의 세그먼트 번지를 저장하고 있는 배열

-------------------------------
  palette_data _palette[256]
-------------------------------
  현재의 팔레트를 기억하고 있다.

-------------------------------
  bool _change_palette_flag
-------------------------------
  팔레트 관련 함수에서 현재 팔레트를 변화시킬 것인가를 나타내는 플랙

-------------------------------
     bool _voice_flag
-------------------------------
  보이스를 출력하고 있는지를 판별하는 플랙. TRUE면 출력중, FALSE면 그 반대이다.

-------------------------------
    FLI_HEADER fli_head
-------------------------------
  fli화일의 헤더 정보를 기억하고 있다.

-------------------------------
      fli_state _fli
-------------------------------
  현재 플레이 되고 있는 FLI화일에 관한 정보가 들어 있다. 자세한 사용법은 User's Guide에 나와 있다.

-------------------------------
     bool _playing_flag
-------------------------------
  음이 연주되고 있는가를 나타낼 때 쓰이며, 음악을 단 한번 연주하고 끝낼 때 응용한다.

-------------------------------
   struct sb_state _sb
-------------------------------
   사운드  블래스터의  상태를  저장하는  변수.  디폴트는  각각  _sb.io_addr이  0x220,  _sb.irq가  7, 
_sb.dma_channel이 1로 되어 있다.

-------------------------------
      bool _use_mouse
-------------------------------
  마우스를 사용중인가 나타낸다.

-------------------------------
     bool _use_multi_key
-------------------------------
  멀티키를 사용중인가 나타낸다.

-------------------------------
    bool _use_cycle_palette
-------------------------------
  팔레트 사이클링을 사용중인가 나타낸다.



 3) 라이브러리 함수

-------------------------------
       action_key()
-------------------------------
원형 : int action_key( void )

  만약 키를 눌렀으면 그 키의 값을 리턴하고 그렇지 않으면 NULL을 리턴한다. 이 함수는 키를 누를 때까지 
기다리지 않고 그냥 지나친다. 실시간 처리에 유용하다.


-------------------------------
      activity_page()
-------------------------------
원형 : void activity_page( word page )

  지정한 인수의 페이지를 활성화 시킨다. 이 함수를 통해 안보이는 페이지에 그려진 그림들이 실제로 화면
에 나타나게 된다. 이 함수를 호출한 후엔 자동적으로 작업 페이지가 0이 된다.


-------------------------------
    activity_page_step()
-------------------------------
원형 : void activity_page( word page, word skip_line, word milli_sec )

  activity_page()와 같으나 그대로 전환되지 않고 라인단위로 부드럽게 전환된다. step는 그 라인이  스크
롤되는 단위이며 항상 1이상이어야 하고, milli_sec는 지연시간이다.


-------------------------------
        all_palette()
-------------------------------
원형 : all_palette( byte color )

  팔레트를 전부 원하는 색깔로 바꾼다. 팔레트 배열엔 영향을 주지 않는다.


-------------------------------
           bar()
-------------------------------
원형 : void bar( int start_x, int start_y, int end_x, int end_y, byte color )

  화면상에 속이 찬 사각형을 그린다. color은 0부터 255까지의 값을 가질 수 있으며, 경계선은 없다.


-------------------------------
        bar_shade()
-------------------------------
원형 : void bar_shade( int start_x, int start_y, int end_x, int end_y, char shade )

  그림자 진 사각형을 그린다. 이 함수를 제대로 활용하려면 잘 구성된 팔레트와 그림자 질 부분을  신경써
서 관리해야 한다. 인수중 shade가 그 그림자 지는 정도이면 이 수가 음수이면 오히려 밝아진다.


-------------------------------
         bar_xor()
-------------------------------
원형 : void bar_xor( int start_x, int start_y, int end_x, int end_y )

   XOR속성으로 속이 찬 사각형을 그린다. 메뉴를 만들 때에 유용한다.


-------------------------------
           box()
-------------------------------
원형 : void box( int start_x, int start_y, int end_x, int end_y, byte color )

  화면상에 속이 빈 사각형을 그린다.


-------------------------------
         box_xor()
-------------------------------
원형 : void box_xor( int start_x, int start_y, int end_x, int end_y )

   XOR속성으로 박스를 그린다. 메뉴나 툴을 만들 때 무척 유용하다.


-------------------------------
     center_user_window()
-------------------------------
원형 : int center_user_window( word size_x, word size_y, window_data *window )

  화면의 중앙에 사용자 정의 윈도우를 연다. 이 경우 보통의 윈도우와는 다른 형태를 취한다. 사용자 윈도
우는 한칸이 16x16으로 구성되어 있는데, 이 패러그래프의 갯수로 윈도우의 크기를 포현한다. 만약 이 크기
가 2보다 작을 경우엔 1을, 윈도우 사이즈가 너무 크면 2를 리턴한다.


-------------------------------
       center_window()
-------------------------------
원형 : int center_window( word size_x, word size_y, window_data *window )

  화면의 중앙에 윈도우를 연다. 윈도우는 x, y의 크기가 각각 12보다 커야만 한다. 만약 성공적으로  윈도
우가 열렸으면 0을 리턴하고 그렇지 않으면 x크기가 작을 때 1을, y크기가 작을 때 2를 리턴한다.


-------------------------------
     change_palette()
-------------------------------
원형 : void change_palette( palette_data *palette_info )

   주어진  팔레트  배열대로  현재의  팔레트를  설정한다.  recover_palette()와   다른   점이   있다면 
recover_palette()는 주 팔레트 배열인 _palette[]를 가지고 팔레트를 설정하나 change_palette()는 인수로 
주어진 팔레트 배열을 가지고 팔레트를 설정한다는 것이다. 오버랩이나 그런 곳에 자주 이용한다.


-------------------------------
   change_palette_part()
-------------------------------
원형 : void change_palette_part( palette_data *palette_info, byte start_color, word change )

  change_palette()와 같으나,  팔레트의  일부만을  바꾼다.  인수인  palette_info는  팔레트  배열이고, 
start_color, change는 각각 팔레트 번호의 시작과 바꿀 팔레트의 갯수를 뜻한다.


-------------------------------
        char_put()
-------------------------------
원형 : void char_put( int x, int y, image_data image )

  copy_put()과 비슷한 일을 수행하나, 투명색에 해당하는 점은 찍지 않는다. 그러므로 폰트 제작시 배경을 
투명색으로 해주면 Shadow 패턴과 같은 효과를 빠르게 구현할 수 있다. 256색중 단 하나를 사용하지 않는다
고 해서 큰 타격은 없을 것이다. 투명색에 해당하는 색은 전역변수 _attr_null_color에 저장되어 있으며 초
기값은 255번 색이다.


-------------------------------
    char_put_flip_both()
-------------------------------
원형 : void char_put_flip_both( int x, int y, image_data image )

  char_put()과 같으나 상화좌우 반전된 이미지를 찍는다.


-------------------------------
    char_put_flip_horiz()
-------------------------------
원형 : void char_put_flip_horiz( int x, int y, image_data image )

  char_put()과 같으나 좌우 반전된 이미지를 찍는다.


-------------------------------
    char_put_flip_vert()
-------------------------------
원형 : void char_put_flip_vert( int x, int y, image_data image )

  char_put()과 같으나 상화 반전된 이미지를 찍는다.


-------------------------------
     char_put_clip()
-------------------------------
원형 : void char_put_clip( int x, int y, copy *image )

  char_put()의 클리핑 버전. 클리핑 체크를  하는만큼  속도가  느리니,  한쪽만  클리핑  하는  경우라면 
char_put_clip_x()나 char_put_clip_y()등의 함수를 쓰는 것이 낫다.


-------------------------------
     char_put_clip_x()
-------------------------------
원형 : void char_put_clip_x( int x, int y, image_data image )

  char_put()의 x클리핑 버전


-------------------------------
     char_put_clip_y()
-------------------------------
원형 : void char_put_clip_y( int x, int y, image_data image )

  char_put()의 y클리핑 버전


-------------------------------
       char_put_cut()
-------------------------------
원형 : void char_put_cut( int x, int y, image_data image, int_skip_x,  int  skip_y,  word  length_x, 
word length_y )
 
 char_put()과 비슷한 역할을 하지만  이미지중 원하는 부분만 찍을 수 있다는 특징이 있다. 이 함수엔  다
른 함수들과 마찬가지로 한계점을 검사하는 루틴이 없으므로(속도 때문) 잘 생각해서 skip과 length를 설정
해야 한다. 그렇지 않으면 프로그램이 폭주하므로 주의하기 바란다.


-------------------------------
      char_put_shade()
-------------------------------
원형 : void char_put_shade( int x, int y, image_data image, char shade )

  char_put()과 비슷하지만 이미지의 그림자를 찍는 다는 것이 다르다. 완전한 그림자가 아닌 약간의  그늘
을 만들어 주는 것이다. 인수인 shade는 양수의 경우엔 더 어두워지나 음수인 경우엔 오히려 밝아진다.  이 
함수를 잘 사용하고 싶다면 먼저 적절히 팔레트를 구성해 놓는 것이 좋다.


-------------------------------
    char_put_shade_clip()
-------------------------------
원형 : void char_put_shade_clip( int x, int y, image_data image, char shade )

  char_put_shade()의 클리핑 버전


-------------------------------
      char_put_shadow()
-------------------------------
원형 : void char_put_shadow( int x, int y, image_data image )

  char_put()과 비슷하지만 이미지를 한가지 색으로 찍는다는 것이 다르다. 즉, 그림자를 찍는 것이다.  찍
는 이미지의 색은 전역변수 _attr_shadow_color에 저장된 값으로 초기값은 검정색이다. 생각보다 괜찮은 효
과를 얻을 수 있다.


-------------------------------
    char_put_shadow_clip()
-------------------------------
원형 : void char_put_shadow_clip( int x, int y, image_data image )

  char_put_shadow()의 클리핑 버전


-------------------------------
        char_to_int()
-------------------------------
원형 : void char_to_int( char char_high, char char_low, int *integer )

  1바이트 char형 변수 두개를 각각 상하위 바이트로 이어서 2바이트 int형 변수로 만든다.


-------------------------------
        check_mouse()
-------------------------------
원형 : bool check_mouse( int start_x, int start_y, int end_x, int end_y )

  지정된 위치 내에 마우스 커서가 위치하고 있는지를 알아낸다. 리턴값은 TRUE, FALSE의 값이다.


-------------------------------
        clear_key()
-------------------------------
원형 : void clear_key( void )

  키버퍼를 청소해 준다.


-------------------------------
        clear_screen()
-------------------------------
원형 : void clear_screen( byte color )

  화면을 지운다. 인수로는 0부터 255까지의 숫자가 들어갈 수 있는데, 지운 후 화면은 이 인수에 해당하는 
색깔로 칠해져 있다.


-------------------------------
       close_game13h()
-------------------------------
원형 : void close_game13h( void )

  프로그램을 모드 3h(80x25, 16Color Text)로 바꾼다. 아울러 이 함수는 마우스 드라이버나 사운드 드라이
버가 활성화 되어 있으면 그것까지 중지시킨다.


-------------------------------
       close_midi()
-------------------------------
원형 : void close_midi( void )

  음악을 종료하고, 모든 소리를 끈 다음 타이머 인터럽트를 원래대로 돌려 놓는다.


-------------------------------
        close_mouse()
-------------------------------
원형 : void close_mouse( void )

  마우스를 리셋한다. 마우스를 사용했다면 프로그램 종료 전에 반드시 실행시켜야 한다.


-------------------------------
        close_page()
-------------------------------
원형 : void close_page( void )

  할당된 페이지를 다시 반납한다. init_page()함수 호출 이후 두개 이상의 페이지가 필요 없어졌을 때  이 
함수를 호출한다. 이 라이브러리는 더블 버퍼링을 이용해 페이지를 구현했으므로 당연히 페이지를 쓰는  만
큼 사용자 메모리는 줄어들게 되어 있다. 그러니 더이상 둘이상의 페이지를 쓸 필요가 없어지면 이  함수를 
호출해야 한다.


-------------------------------
       close_voice()
-------------------------------
원형 : void (*close_voice)( void )

  VOC 출력장치를 해제한다.


-------------------------------
       close_window()
-------------------------------
원형 : void close_window( window_data *window )

  open_window(), open_user_window(), center_window(), center_user_window()등으로 열린 윈도우를  닫는
다. 반드시 연 윈도우는 이 함수로 닫아야 하는데, 이유는 윈도우를 열 때 쓴 버퍼를 반납해야 하기 때문이
다.


-------------------------------
        copy_page()
-------------------------------
원형 : void copy_page( word sorce_page, word target_page )

  페이지에서 페이지로 이미지를 복사한다. 인수로 쓸 수 있는 수는 0 ~  _last_page_number사이의  숫자이
며, 이중 target_page가 0일 때엔 activity_page()함수처럼 현재의 화면으로 복사를 한다. 복사가 끝난  다
음의 _page_number엔 변화가 없다.


-------------------------------
      copy_page_char()
-------------------------------
원형 : void copy_page_char( word source_page, word target_page, int s_x, int s_y, int e_x, int e_y )

  원하는 페이지의  지정된  위치의  그림을  다른  페이지로  부분  복사한다.  이때  복사되는  이미지는 
char_put()과 같이 배경색에 해당하는 색은 투명색으로 취급되어 복사하지 않는다. 무척 유용한 함수이다.


-------------------------------
    copy_page_char_horiz()
-------------------------------
원형 : void copy_page_char_horiz( word source_page, word target_page, int start_y, int end_y )

  copy_page_char()과 같으나 전송범위를 y좌표로 한정시킬 수 있다. 수평위치 start_y부터 end_y까지 화면
을 복사한다.


-------------------------------
      copy_page_cut()
-------------------------------
원형 : void copy_page_cut( word source_page, word target_page, int s_x, int s_y, int e_x, int e_y )

  페이지의 일부만을 전송한다. 한 페이지에서 다른 페이지로 화면의 일부만을 복사할 때 이 함수는 상당히 
유용하게 쓰일 것이다.


-------------------------------
    copy_page_horiz()
-------------------------------
원형 : void copy_page_horiz( word source_page, word target_page, int start_y, int end_y )

  페이지의 일부만을 복사한다. 전송범위는 y좌표로 한정시킬 수 있다. 수평위치 start_y부터 end_y까지 화
면을 복사한다.


-------------------------------
     copy_page_move()
-------------------------------
원형 : void copy_page_move( word source_page, word target_page, int s_x, int s_y, int e_x, int  e_y, 
int t_x, int t_y )
 
 copy_page_cut()과 비슷한 작용을 하나, 복사될 화면의 다른 위치로 복사하는 것이 가능하다.


-------------------------------
         copy_put()
-------------------------------
원형 : void copy_put( int x, int y, image_data image )

  put_image()함수 'c'옵션과 동일한 일을 수행한다. MOVSW명령을 사용했기 때문에 무척 빠른 속도로  수행
된다.


-------------------------------
      copy_put_clip()
-------------------------------
원형 : void copy_put_clip( int x, int y, image_data image )

  copy_put()의 클리핑 버전. 클리핑 체크를  하는만큼  속도가  느리니,  한쪽만  클리핑  하는  경우라면 
copy_put_clip_x()나 copy_put_clip_y()등의 함수를 쓰는 것이 낫다.


-------------------------------
      copy_put_clip_x()
-------------------------------
원형 : void copy_put_clip_x( int x, int y, image_data image )

  copy_put()의 x클리핑 버전


-------------------------------
     copy_put_clip_y()
-------------------------------
원형 : void copy_put_clip_y( int x, int y, image_data image )

  copy_put()의 y클리핑 버전


-------------------------------
     copy_put_flip_both()
-------------------------------
원형 : void copy_put_flip_both( int x, int y, image_data image )

  copy_put()과 같으나 상화좌우 반전된 이미지를 찍는다.


-------------------------------
    copy_put_flip_horiz()
-------------------------------
원형 : void copy_put_flip_horiz( int x, int y, image_data image )

  copy_put()과 같으나 좌우 반전된 이미지를 찍는다.


-------------------------------
    copy_put_flip_vert()
-------------------------------
원형 : void copy_put_flip_vert( int x, int y, image_data image )

  copy_put()과 같으나 상화 반전된 이미지를 찍는다.


-------------------------------
      cycle_palette()
-------------------------------
원형 : void cycle_palette( byte start_color, byte end_color )

  팔레트를 원하는 범위 내에서 순환 시킨다. start_color은 시작 색깔, end_color은 마지막 색깔이다.  만
약 이 위치가 반대로 되면 자동으로 순환방향도 반대가 된다. 단, 주 팔레트 배열인 _palette[]의 값도  바
뀌어 버린다는 것에 주의. DP의 경우엔 실제론 폰트를 위해 비워둔 색이 있다. 이 색은 0xE0 ~  0xE7까지인
데 각각 S_CYCLE와 E_CYCLE로 헤더에 정의되어 있다. 색상을 해치지 않기 위해 이 범위의 색을  사이클링에 
이용하는 것도 좋을 것이다.


-------------------------------
      decode_picture()
-------------------------------
원형 : void decode_picture( char *data, word page )

   주어진  포인터의  RLE방식의  그림을  디코딩하여  원하는  페이지에  그린다.  직접   사용하기보다는 
load_picture()나 load_overlab()등의 함수를 통해 사용되다. 가끔 툴을 만들게 될 때에  유용하게  사용될 
수도 있다.


-------------------------------
        delay_key()
-------------------------------
원형 : void delay_key( void )

  아무 키나 누를 때까지 기다린다. 이미 이때는 키 버퍼가 깨끗이 청소된 후이다.


-------------------------------
       delay_program()
-------------------------------
원형 : void delay_program( word milli_sec )

  1/1000 초 단위로 프로그램을 지연시킨다. Turbo C의 delay()함수는 약간의 버그가 있을 뿐만 아니라  기
종에 따라 딜레이되는 시간이 다르다. 그러나 이 함수는 기종에 관계없이 정상적으로 작동하며 게다가  C의 
delay()함수보다 더 정확하다. 이 함수는 인터럽트를 이용하기 때문에 setvect()같은 함수에  의해  가로챈 
함수 속에서 호출되면 문제가 발생하므로 주의하기 바람.


-------------------------------
       draw_button()
-------------------------------
원형 : void draw_button( int start_x, int start_y, int end_x, int end_y, button_data *button )

  화면에 버튼을 그린다. 리턴값은 그려진 버튼에 관한 데이터이다.


-------------------------------
     draw_user_window()
-------------------------------
원형 : int draw_user_window( int x, int y, word size_x, word size_y )

  화면에 사용자 정의 윈도우를 그린다. 이 경우 보통의 윈도우와는 다른 형태를 취한다. 사용자  윈도우는 
한칸이 16x16으로 구성되어 있는데, 이 패러그래프의 갯수로 윈도우의 크기를 포현한다. 만약 이 크기가  2
보다 작을 경우엔 1을, 윈도우 사이즈가 너무 크면 2를 리턴한다.


-------------------------------
       draw_window()
-------------------------------
원형 : int draw_window( int start_x, int start_y, int end_x, int end_y )

  화면에 윈도우를 그린다. 윈도우는 x, y의 크기가 각각 12보다 커야만 한다. 만약  성공적으로  윈도우가 
열렸으면 0을 리턴하고 그렇지 않으면 x크기가 작을 때 1을, y크기가 작을 때 2를 리턴한다.


-------------------------------
       fade_change()
-------------------------------
원형 : void fade_change( palette_data *source, palette_data *target, word step, word milli_sec )

  한 팔레트 배열에서 다른 팔레트 배열로 팔레트를 부드럽게 변화시킨다. 이 함수를 이용하며 여러가지 화
려한 효과를 낼 수가 있다. Over Lab을 구현하거나 팔레트가 부드럽게 흑백으로 바뀐다거나하는 복잡해  보
이는 효과도 이 함수로 쉽게 구현할 수 있다. 무척 유용한 함수이다.


-------------------------------
      fade_change_part()
-------------------------------
원형 : void fade_change_part( palette_data *source, palette_data *target, word step, word milli_sec, 
byte start, word change )
 
 fade_change()와 같으나 팔레트의 일부만을 대상으로 한다. start는 시작 색, change는 바꿀 색의 수를 지
정한다.


-------------------------------
      fade_change_step()
-------------------------------
원형 : void fade_change_step( palette_data *source, palette_data *target, word step )

  fade_change()와 같은 역할을 하지만 정해진 단계만 진행하고 정지한다. 이 함수를 쓰면 작업도중에 백그
라운드로 팔레트를 변환시키거나 일정한 단계로 화면의 색상이나 분위기가 변하게 할 수 있다.


-------------------------------
         fade_in()
-------------------------------
원형 : void fade_in( byte source_color, word step, word milli_sec )

  팔레트를 다시 정상(팔레트 배열)으로 회복시킨다. 단, 단색에서 출발해야 한다. fade_out()함수와  함께 
쓰면 훌륭한 효과를 거둘 수 있을 것이다. step은 전체 단계로, 1부터 64중에 한 숫자로 해야 한다. 숫자가 
클수록 더 부드럽게 진행한다. milli_sec는 각 단계마다 줄 지연시간이다. 경험에 의하면 단계는 32,  지연
시간은 25로 하는 것이 적합한 결과를 나타냈다.


-------------------------------
      fade_in_part()
-------------------------------
원형 : void fade_in_part( byte source_color, word step, word milli_sec, byte start, word change )

  fade_in()과 같으나 팔레트의 일부만을 대상으로 한다. start는 시작 색, change는 바꿀 색의 수를  지정
한다.


-------------------------------
       fade_in_rgb()
-------------------------------
원형 : void fade_in_rgb( byte red, byte green, byte blue, word step, word milli_sec )

  fade_in()과 같으나 RGB속성으로 Fade In을 진행한다. 이 것을 쓰면 fade_in()보다 더  다양하게  제어할 
수 있으나 사용방법은 더 불편하니 보통의 경우엔 그냥 fade_in()을 쓰는 것이 낫다.


-------------------------------
      fade_in_step()
-------------------------------
원형 : void fade_in_step( byte source_color, word step )

  fade_in()과 같은 역할을 하지만 정해진 단계만 진행하고 정지한다. step은 진행할 단계 수로 전체  단계
는 64이다. 이 함수를 쓰면 작업도중에 백그라운드로 Fade In이 되도록 할 수 있다.


-------------------------------
         fade_out()
-------------------------------
원형 : void fade_out( byte target_color, word step, word milli_sec )

  팔레트를 원하는 색상으로 점차적으로 변해가게 만든다. 게임의 데모나 화면  전환시  유용한  함수이다. 
step은 팔레트가 변하는 전체 스텝이고, milli_sec는 지연시간이다.


-------------------------------
      fade_out_part()
-------------------------------
원형 : void fade_out_part( byte target_color, word step, word milli_sec, byte start, word change )

  fade_out()과 같으나 팔레트의 일부만을 대상으로 한다. start는 시작 색, change는 바꿀 색의 수를 지정
한다.


-------------------------------
      fade_out_rgb()
-------------------------------
원형 : void fade_out_rgb( byte red, byte green, byte blue, word step, word milli_sec )

  fade_out()과 같으나 RGB속성으로 Fade Out을 진행한다. 이 것을 쓰면 fade_out()보다 더 다양하게  제어
할 수 있으나 사용방법은 더 불편하니 보통의 경우엔 그냥 fade_out()을 쓰는 것이 낫다.


-------------------------------
      fade_out_step()
-------------------------------
원형 : void fade_out_step( byte target_color, word step )

  fade_out()과 같은 역할을 하지만 정해진 단계만 진행하고 정지한다. 이 함수를 쓰면 작업도중에  백그라
운드로 Fade Out이 되도록 할 수 있다.


-------------------------------
      fix_palette()
-------------------------------
원형 : void fix_palette( void )

  현재의 팔레트를 정착시킨다. 여러가지 작업을 하면서 생긴 팔레트의 변화를 아예 팔레트 배열에  넣어버
려 팔레트를 계속 참조할 수 있게 만드는 것이다.


-------------------------------
    fix_palette_array()
-------------------------------
원형 : void fix_palette_array( palette_data *array, byte start_color, word change )

  fix_palette()와 같지만, fix_palette()는 전역변수인 _palette라는 배열에 팔레트를  정착시키는  반면, 
이 함수는 인수로 주어진 팔레트 배열에 현재의 팔레트를 정착시킨다. 인수중  array가  팔레트  배열이며, 
start_color은 시작할 컬러, change는 정착시킬 색을 갯수를 각각 지정한다.


-------------------------------
          fli_play()
-------------------------------
원형 : int fli_play( char *file_name, char mode )

  FLI화일을 플레이한다. 플레이 조건은 함수 포인터 _fli.stop이 가리키는 함수가 TRUE를  리턴하지  않는 
한 계속된다. 만약 _fli.stop이 NULL이라면 플레이는 단 한번만 이루어진다. 플레이 중에 백그라운드로  무
엇인가 처리할 일이 있다면 함수 포인터 _fli.before와 _fli.after를 이용한다. 이 함수 포인터는 각각  한 
프레임이 시작되기 전과 후에 실행되도록 되어 있다. 또한 _fli.frame라는 전역변수는 현재 진행되고  있는 
프레임의 번호를 지정한다. 성공적으로 실행되면 NULL을 리턴하고 그렇지 않을 땐, 화일이  없는  경우  1, 
FLI화일이 아닐 땐 2, FLI화일의 내부에 이상이 있을 때(잘못된 프레임이 포함되어 있을 때)는 3을  리턴한
다. 모드는 사용자 수준의 문제인데, 사용자가 모든 부분을 자신이 제어하기를 원한다면 Control모드로  하
고, 그렇지 않다면 그냥 Normal모드로 한다.
 'n' - Normal모드. 일정한 지연시간을 준다.
 'c' - Control모드. 사용자가 모든것을 처리하도록 지연시간을 주지 않는다.


-------------------------------
         free_icon()
-------------------------------
원형 : void free_icon( icon_data *icon )

  아이콘 배열을 해제한다. 아이콘 배열은 load_icon()로 읽을 때 미리 메모리가 할당되므로 사용할 필요가 
없어진 아이콘 배열은 이 함수를 써서 메모리를 반납하게 되어 있다.


-------------------------------
        free_voice()
-------------------------------
원형 : void free_voice( voice_data *data )

  보이스 출력을 위해 할당된 메모리를 해제한다.


-------------------------------
         gen_menu()
-------------------------------
원형 : int gen_menu( char *message[], int max_row, int disp_row )

  메뉴를 만든다. 인수가 되는 message는 문자열의  배열이다.  max_row로는  그  향목의  갯수를  넣는다. 
disp_row는 화면에 나타는 항목의 갯수이며 만약 max_row가 이 값보다 더 크면 메뉴가 스크롤되나.  리턴값
은 선택한 항목이고 ESC를 누르면 CANCEL을 리턴한다. 항목이 9개가 넘거나  문자열이  27컬럼을  넘어가면 
CANCEL을 리턴한다.


-------------------------------
         gen_menu_small()
-------------------------------
원형 : int gen_menu_small( char *message[], int max_row, int disp_row )

  gen_menu()와 같으나 내부적으로 make_str_small()함수를 사용하기 때문에 작은 메뉴가  나온다.  그래서 
항목은 더 확장된 12개, 컬럼은 60개로 한정된다. 단, 한글은 사용할 수 없다.


-------------------------------
        get_dword()
-------------------------------
원형 : dword get_dword( char *ptr )

  정해진 포인터에서 더블 워드형 데이터를 추출하여 리턴한다. 데이터 추출 방식은 역워드 방식을  따르지 
않는다. 즉 우리가 쓰는 그 데이터 형식을 그대로 쓴다. 주로 보이스 화일이나 음악 화일을 처리할 때 내부
적으로 쓴다.


-------------------------------
       get_exec_path()
-------------------------------
원형 : void get_exec_path( char *path )

  현재의 풀 패스명을 얻는다.


-------------------------------
        get_image()
-------------------------------
원형 : void get_image( int start_x, int start_y, int end_x, int end_y, image_data *image )

  이미지 데이터를 버퍼로 읽어 들인다. BASIC의 GET명령문과 같은데 터보 C에도 동일한 함수가  존재한다. 
단지 이 함수는 쓰기가 편하게 꾸며져 있다. 터보 C에서처럼 일일이 이미지의 크기를 구해 메모리를 할당해 
줄 필요가 없이 함수가 알아서 다 해준다. 이것은 이 라이브러리가 모드 13h 전용으로 만들어 졌기  때문에 
가능하다. 그러나 자신이 메모리를 할당해 주지 않았다고 자신이 그 메모리를 반납할 필요가  없다는  말은 
아니다. 필요가 없어지면 farfree()함수를 이용해 반드시 메모리를 반납해야 한다. 그렇지 않으면 지금  당
장은 문제가 없더라도 계속 사용하다보면 메모리가 모자라서 시스템이 다운되거나 그 이상의 심각한 사태가 
발생하기도 한다.


-------------------------------
        get_image_clip()
-------------------------------
원형 : void get_image_clip( int start_x, int start_y, int end_x, int end_y, image_data *image )

   get_image()의 클리핑 버전.


-------------------------------
        get_image_fix()
-------------------------------
원형 : void get_image_fix( int start_x, int start_y, int end_x, int end_y, image_data image )

  이 함수는 get_image()와 같으나 스스로 이미지를 저장할 메모리를 할당하지 않는다는 점에서 Turbo  C의 
getimage()와 같은 작용을 하는 함수이다. 보통 반복해서 이미지를 잡아 찍는 경우엔 get_image()보다 한번 
get_image()로 잡은 포인터를 가지고 계속 get_image_fix()를 쓰는 것이 낫다.


-------------------------------
     get_image_fix_clip()
-------------------------------
원형 : void get_image_fix_clip( int start_x, int start_y, int end_x, int end_y, image_data image )

  get_image_fix()의 클리핑 버전. 배열 중에 남는 부분은 건드리지 않고 그냥 놔 둔다. 주로 마우스  루틴
에서 내부적으로 사용하는 함수이다.


-------------------------------
       get_joy_skick()
-------------------------------
원형 : void get_joy_stick( inc *x, int *y )

  죠이스틱의 위치를 리턴한다. 위치는 각각 x, y좌표로 -300부터 300까지이다.


-------------------------------
       get_joy_button()
-------------------------------
원형 : int get_joy_button( void )

  죠이스틱의 버튼을 리턴한다. 주버튼은 1, 부버튼은 2, 둘을 함께 누르면 3을 각각 리턴한다.


-------------------------------
          get_key()
-------------------------------
원형 : int get_key( void )

  키보드 버퍼를 청소해주고 키 하나를 받아들여 그것의 아스키 코드나, 혹은 스캔 코드를 리턴한다.  보통
은 그냥 아스키 코드를 리턴하나 화살표 키등은 아스키 코드의 값을 갖지 않으므로  스캔코드를  리턴한다. 
이런 경우 4자리 16진수로 리턴된다. 즉, ENTER과 같은 키는 0x0D의 값을 리턴하나,  LEFT키와  같은  키는 
0x4B00같은 아랫자리수가 0인 값을 갖는다. 몇개 자주 쓰이는 키는 헤더화일에 정의해  놓았으니  참고하기 
바란다.
이 함수는 한 문자까지의 키버퍼를 참조한다.


-------------------------------
     get_mouse_button()
-------------------------------
원형 : bool get_mouse_button( int button )

  현재 특정 마우스의 버튼 값을 얻는다. 리턴되는 값은 TRUE나 FALSE의 값이다.


-------------------------------
        get_palette()
-------------------------------
원형 : palette_data get_palette( byte color_no )

  지정된 색의 팔레트 RGB값을 얻어온다. 이 값은 배열에 저장된 값이 아니라 실제로 DAC에 저장된  팔레트
의 값이다.


-------------------------------
        get_pixel()
-------------------------------
원형 : byte get_pixel( int x, int y )

  지정된 위치의 점을 읽어 그 색깔 코드를 리턴한다.


-------------------------------
        get_word()
-------------------------------
원형 : word get_word( char *ptr )

  정해진 포인터에서 워드형 데이터를 추출하여 리턴한다. 데이터 추출 방식은 역워드 방식을 따르지  않는
다. 즉 우리가 쓰는 그 데이터 형식을 그대로 쓴다. 예를 들어 내부에 0x12가 먼저 들어가 있고 0x34가  나
중에 들어가 있어면 그대로 추출하면 0x3412로 추출되나 이 함수를 쓰면 0x1234가 그대로  추출된다.  주로 
보이스 화일이나 음악 화일을 처리할 때 내부적으로 쓴다.


-------------------------------
      gray_palette()
-------------------------------
원형 : void gray_palette( word gray_color )

  팔레트에 그레이 스케일링을 적용한다. color는 그 옵션이다.
 BLACK - 흑백으로 바꾼다.
 RED   - 붉은색으로 바꾼다.
 GREEN - 초록색으로 바꾼다.
 BLUE  - 푸른색으로 바꾼다.


-------------------------------
    gray_palette_array()
-------------------------------
원형 : void gray_palette_array( word gray_color, palette_data *pal_array )

  gray_palette()와 같지만 팔레트 값을 변환하지 않고 특별한 효과를 낼 수 있도록 변환된 그레이  스케일
링은 배열에 적재된다. 이렇게 한 다음에 fade_change()따위의 함수를 쓰면 상당한 효과를 거둘 수가 있다.

  
-------------------------------
        image_copy()
-------------------------------
원형 : void image_copy( image_data source_image, image_data *target_image )

  현재의 이미지를 복사한 똑같은 이미지를 하나 만들어 준다.


-------------------------------
      image_flip_both()
-------------------------------
원형 : void image_flip_both( image_data source_image, image_data *target_image )

  현재의 이미지를 상하좌우 뒤바꾼 이미지를 만들어 낸다.


-------------------------------
      image_flip_horiz()
-------------------------------
원형 : void image_copy_horiz( image_data source_image, image_data *target_image )

  현재의 이미지를 좌우로 뒤바꾼 이미지를 만들어 낸다.


-------------------------------
      image_flip_vert()
-------------------------------
원형 : void image_copy_vert( image_data source_image, image_data *target_image )

  현재의 이미지를 상하로 뒤바꾼 이미지를 만들어 낸다.


-------------------------------
       image_scale()
-------------------------------
원형 : void image_scale( int x, int y, image_data original_image, word scale_x, word scale_y )

  이미지를 정수배로 확대해서 화면에 표시한다. 주의할 것은 이미지의 클리핑 체크를 하지 않기 때문에 잘
못하면 엉뚱한 결과를 가져올 수가 있따. scale_x, scale_y가 각각 확대할 스케일인데, 모두 1보다  크거나 
같은 수로 해야만 한다.


-------------------------------
        image_size()
-------------------------------
원형 : word image_size( image_data image )

  주어진 이미지의 크기를 알아낸다. 이것은 헤더를 포함한 크기로 이미지 전체가 차지하는 크기이다.


-------------------------------
       image_size_xy()
-------------------------------
원형 : void image_size_xy( image_data image, word *x, word *y )

  주어진 이미지의 x, y크기를 알아낸다.


-------------------------------
     image_translate()
-------------------------------
원형 : void image_translate( image_data source_image, image_data *target_image, char trans )

  현재의 이미지의 색번호를 일괄적으로 Add시킨다. 용도를 찾을 경우엔 무척 편리한 함수가 된다. trans는 
더해지는 값으로 이 값이 음수가 되면 오히려 Sub연산이 된다. 투명색은 효과에서 제외된다.


-------------------------------
        image_zoom()
-------------------------------
원형 : void image_zoom( image_data source_image, image_data *target_image, word new_x, word new_y )

  이미지를 자유롭게 확대 축소한다. 인수중 new_x, new_y는 각각 확대 혹은 축소시킨 새로운 x, y의  크기
이다.


-------------------------------
      incode_picture()
-------------------------------
원형 : word incode_picture( char **data, word page )

  원하는 페이지의 그림을 RLE방식으로 압축하여 포인터 data로 넘겨준다. 이 과정에서 data에는 새로운 메
모리가 할당되므로 나중에 필요가 없어지면 farfree()로 메모리를 해제해야 한다. 제대로 압축되면 그 압축
된 이미지의 크기가 리턴되며 만약 압축에 실패하면(압축한 크기가 오히려 64000을 넘어가면)  0을  리턴한
다.


-------------------------------
       index_cursor()
-------------------------------
원형 : void index_cursor( int x, int y, byte color )

  화면에 16x16보다 한칸씩 더 큰 사각형 상자로 커서를 표시한다. 이 함수는 보통 다른 함수에 내부적으로 
참조된다.


-------------------------------
       init_game13h()
-------------------------------
원형 : void init_game13h( void )

  게임 라이브러리를 초기화 한다. 이 함수가 하는 역할은 두가지이다. 첫째는 모드 13h로 바꾸어 주는  것
이고, 둘째론 딜럭스 페인트 팔레트로 바꾸어 주는 것이다.


-------------------------------
       init_midi()
-------------------------------
원형 : void init_midi( void )

  MDI모듈을 초기화 시킨다.


-------------------------------
     init_mouse()
-------------------------------
원형 : int init_mouse( void )

   마우스를 초기화 시킨다. 이 루틴에 앞서 마우스 드라이버가 실행되어 있어야 되는 것은 말할 나위가 없
다. 마우스가 성공적으로 초기화되면 0을 그렇지 않으면 1을 리턴한다.


-------------------------------
        init_page()
-------------------------------
원형 : int init_page( word add_page )

  사용할 페이지에 해당하는 버퍼를 할당해 준다. 두개 이상의 페이지를 쓰기 위해선 이 함수를 반드시  호
출해야 한다. 인수인 add_page는 추가될 페이지의 갯수로, 1에서 3까지의 인수를 줄 수 있다. 예를 들어 만
약 1라고 인수를 주면 0페이지와 1페이지를 쓸 수 있는 것이다. 만약 3 이상의 인수를 주면 1을 리턴한다.


-------------------------------
        init_voice()
-------------------------------
원형 : void init_voice( int sound_dev )

  보이스 출력함수를 초기화 시킨다. 버전 4.0까지 지원하던 COVOX는 4.1 이상에선 지원하지 않는다.  인수
는 사운드 디바이스를 지정하는데, NO_VOICE는 보이스  출력을  하지  않을  때,  PC_SPEAKER는  PC스피커, 
S_BLASTER는 사운드 블래스트 카드를 각각 뜻한다. 이중에 스피커로 출력할 땐 CMOS인터럽트를 이용하고 사
운드 블래스트의 경우엔 DMA를 이용한다.


-------------------------------
      input_string()
-------------------------------
원형 : int input_string( int x, int y, char *str, byte color, word length )

  원하는 형태의 데이터를 원하는 길이만큼 키보드에서 입력받는다. 이 함수는 특수한  환경하에  만들어서 
배경이 밝은 회색일 때에만 제대로 작동한다. 이것이 큰 제약은 아니지만 백 스페이스 키를 누르면 왜 이런
지 알게 된다. 이 함수의 효용성을 그렇게 높게 평가하지 않아서 간단하게 쓸 수 있게 만들었기  때문이다. 
차차 보완할 생각이다. 리턴값은 완전히 입력했을 경우 ENTER를, 도중에 ESC을 눌렀을 경우엔 ESC를 리턴해
준다.


-------------------------------
       int_to_char()
-------------------------------
원형 : void int_to_char( int integer, char *char_high, char *char_low )

  2바이트 int변수의 상하위 바이트를 나누어서 각각 1바이트 char형을 세트한다.


-------------------------------
         line()
-------------------------------
원형 : void line( int start_x, int start_y, int end_x, int end_y, byte color )

  시작 좌표와 끝 좌표를 잇는 직선을 그린다. 클리핑 체크를 하지 않는다.


-------------------------------
        line_cross()
-------------------------------
원형 : void line_cross( int x, int y, word length, byte color )

  주어진 점에서 시작하여 인수로 주어진 길이만큼 대각선을 그린다.

 
-------------------------------
        line_horiz()
-------------------------------
원형 : void line_horiz( int x, int y, int length, byte color )

  주어진 점에서 시작하여 인수로 주어진 길이만큼 수평선을 그린다.


-------------------------------
        line_vert()
-------------------------------
원형 : void line_vert( int x, int y, int length, byte color )

  주어진 점에서 시작하여 인수로 주어진 길이만큼 수직선을 그린다.


-------------------------------
        load_icon()
-------------------------------
원형 : int load_icon( char *file_name, icon_data *icon, word start, word icon_number )

  디스크에서 아이콘 화일을 읽어들인다. Game13h에서 지원하는 아이콘 화일 형식은 ICO로서, 자세한  설명
은 유저 가이드를 보라. 아이콘은 보통 여러개가 함께 들어있는 경우가 많은데, 읽기 시작할 아이콘의 번호
와 읽을 갯수를 인수로 받아들여서 아이콘 배열에 차례로 읽어들인다. 이 함수는 주어진  포인터의  배열에 
차례로 메모리를 할당하므로 아이콘이 쓸모 없어졌을 경우엔 free_icon()함수로 메모리를  반납해야  한다. 
이것을 위해선 미리 몇개의 아이콘을 읽어들일 것인가를 알고 있어야 한다. 성공적으로 아이콘을  읽어들였
으면 0을 리턴하나, 화일이 없으면 1, 화일이 있어도 ICO형식과 다르면 2, 읽으려고 한 갯수가 너무 많으면 
3을 각각 리턴한다.


-------------------------------
        load_image()
-------------------------------
원형 : int load_image( char *file_name, image_data *image, word image_number )

  디스크에서 이미지 화일을 읽어들인다. Game13h에서 지원하는 이미지 화일 형식은 IMG로서, 자세한  설명
은 유저 가이드를 보라. image_number은 이미지의 번호로서, 원래 IMG화일은 두개 이상의 이미지를 함께 저
장할 수가 있다. 그 그림중 원하는 이미지를 얻을 수가 있는 것이다. 성공적으로 읽으면 0을, 화일이  없으
면 1, 화일이 있어도 IMG화일의 형식이 아니면 2, 읽고자 하는 이미지가 없으면 3을 각각 리턴한다.


-------------------------------
         load_font()
-------------------------------
원형 : int load_font( int han_font, int eng_font, char *path )

  디스크에서 폰트를 읽어들인다. 단, 디스크상에 폰트화일인 HAN_M16.FNT이나 HAN_G16.FNTG, ENG_G16.FNT, 
ENG_I16.FNT, ENG_P16.FNT, ENG_O16.FNT화일이 있어야만 한다. 만약 성공적으로 폰트를 읽어들였으면  0을, 
한글폰트가 없을 때 1, 영문폰트가 없을 땐 2를 리턴한다. 인수는 폰트를 결정하는 인수와 폰트화일이 있는 
패스를 지정한다.
 - han_font;
 H_NULL - 한글 폰트를 읽지 않는다.
 H_GT   - 한글 고딕체
 H_MJ   - 한글 명조체
 H_PI   - 한글 필기체

 - eng_font;
 E_NULL - 영문 폰트를 읽지 않는다.
 E_GT   - 영문 고딕체
 E_MJ   - 영문 이탤릭체
 E_IT   - 영문 필기체
 E_OB   - 영문 Orbit체


-------------------------------
    load_font_user_han()
-------------------------------
원형 : int load_font_user_han( char *file_name )

  사용자가 정의한 한글폰트를 세트한다. 인수는 화일명이며, 폰트  화일이  없을  경우엔  1을  리턴한다. 
Game13h에선 기본적으로 16x16크기의 폰트에, 한글 벌수가 6-2-1로 사용하고 있다. 즉, 초성 6벌,  중성  2
벌, 종성 1벌씩이다. 메모리를 절약하기 위해 최대한 줄인 것이지만 보기에 큰 무리는 없다.


-------------------------------
    load_font_user_eng()
-------------------------------
원형 : int load_font_user_eng( char *file_name )

  사용자가 정의한 영문폰트를 세트한다. 인수는 화일명이며, 폰트  화일이  없을  경우엔  1을  리턴한다. 
Game13h에서 사용하고 있는 영문 폰트는 '!'부터 '~'까지의 94개 폰트이며 크기는 8x16으로 구성되어 있다.


-------------------------------
      load_overlab()
-------------------------------
원형 : int load_overlab( char *file_name, byte page, palette_data *pal_1, palette_data *pal_2 )

  디스크에서 오버랩 화일을 읽어 원하는 페이지에 전개한다. Game13h에서 지원하는  이미지  화일  형식은 
GOL(Game Over Lab)로서, 자세한 설명은 유저 가이드를 보라. 현재 GOL 버전 1h에선 단지 하나의 그림과 변
환될 팔레트 2개만을 갖고 있을 뿐이며, 화일의 확장성이 결여되어 있다. 그러나 오버랩의 경우엔 많은  노
력을 들여서 만들어야 하기 때문에 이정도로도 충분하다고 생각한다. 이미지는 읽을 당시에 이미 두개의 그
림이  겹쳐진  상태이므로  화면에  표시하기  전에  먼저  팔레트를  바꾸어  놓는  것이  좋다.   방법은 
set_monitor()을 이용해서 화면을 안보이게 한 다음 작업을 진행하거나 다른 페이지에 그림을 로드하는  것
이 좋다. 일단 읽은 후에는 pal_1, pal_2를 이용해서 fade_change()로 오버랩을 진행한다. 성공적으로 읽으
면 0을, 화일이 없으면 1, 화일이 있어도 IMG화일의 형식이 아니면 2를 각각 리턴한다.


-------------------------------
       load_palette()
-------------------------------
원형 : int load_palette( char *file_name, word pal_number )

  디스크에서 팔레트 화일을 읽어들인다. Game13h에서 지원하는 이미지 화일 형식은 PAL로서, 자세한  설명
은 유저 가이드를 보라. pal_number은 팔레트의 번호로서, 원래 PAL화일은 두개 이상의 팔레트를 함께 저장
할 수가 있다. 그 팔레트중 원하는 팔레트를 얻을 수가 있는 것이다. 성공적으로 읽으면 0을, 화일이  없으
면 1, 화일이 있어도 PAL화일의 형식이 아니면 2, 읽고자 하는 팔레트가 없으면 3을 각각 리턴한다.


-------------------------------
       load_picture()
-------------------------------
원형 : int load_picture( char *file_name, word pic_number )

  디스크에서 GPG화일을 읽어들인다. GPG화일은 Game Picture Group의 약자로 그림이 한개인 경우도 있지만 
그 이상의 그림이 들어있기도 한다. pic_number은 그림의 번호로서, 처음 그림은 0번으로 되어 있다.  성공
적으로 로드하면 0을 리턴하지만, 화일이 없을 경우엔 1, 화일이 있더라도 형식이 다른 화일이면  2,  만약 
주어진 인수에 해당하는 그림이 없으면 3을 각각 리턴한다. GPG화일의 자세한 설명은 유저 가이드를 보라.


-------------------------------
     load_user_window()
-------------------------------
원형 : int load_user_window( char *file_name )

  사용자 정의 윈도우 화일을 읽어들인다. 사용자 윈도우는 확장자가 WIN으로서 간단히 로드하기만 하면 이
후로 사용하는 사용자 정의 윈도우는 읽어들인 윈도우로 바뀌게 된다. 리턴값은 화일이 없을 경우 1,  화일
이 있으나 잘못된 형식을 갖고 있을 경우엔 2를 리턴한다.


-------------------------------
        load_voice()
-------------------------------
원형 : int load_voice( char *file_name, voice_data *data )

  VOC화일을 읽어들인다. 읽기 전에 메모리를 스스로 할당하므로 미리 할당할 필요가 없다. 그러나  스스로 
메모리를 해소해 주지 않기 때문에 필요가 없어지면 free_voice()를 이용해 사용자가 반납해야 한다. 이 함
수에서 읽어들일 수 있는 VOC화일의 크기는 64000바이트이며 이것을 넘어서면 64000에서 자른다.


-------------------------------
    locate_mouse_cursor()
-------------------------------
원형 : void locate_mouse_cursor( int x, int y )

  마우스 커서를 원하는 위치로 옮겨 놓는다.


-------------------------------
       make_message()
-------------------------------
원형 : void make_message( char *message[], word row )

  화면의 중앙에 윈도우를 연 후에 2차원 배열인 데이터를 찍는다. 아무 키나 누르면 이  함수는  윈도우를 
닫고 종료된다.


-------------------------------
        make_str()
-------------------------------
원형 : void make_str( int x, int y, char *str_data, byte color )

  스트링을 만든다. 특징으로는 한글을 쓸 수 있다는 점과 딜레이 타임을 줄 수 있다는 것이다. 이  딜레이 
타임은 게임등의 메세지를 처리할 때 유용하게 쓸 수 있다. 딜레이 타임은 글자 하나와 다음 글자가 표시되
기까지의 시간인데 1/1000초 단위로 지연시킨다. 전역변수 _message_delay라는 함수의 값을 조정하면 된다.


-------------------------------
      make_str_double()
-------------------------------
원형 : void make_str_double( int x, int y, char *str_data, byte color, int high )

  글씨를 입체감이 나도록 쓴다. high는 높이이다. 나머지는 make_str()와 같다.


-------------------------------
      make_str_multi()
-------------------------------
원형 : void make_str_multi( int x, int y, char *str_data, byte start_color )

  make_str()과 같으나 멀티 컬러로 폰트를 출력한다. 인수로 준 start_color을 기점으로 폰트의 색으로 차
차 증가시키며 폰트를 찍는다.


-------------------------------
      make_str_small()
-------------------------------
원형 : void make_str_small( int x, int y, char *str_data, byte color )

  화면에 4x6폰트를 가지고 문자열을 만든다. 이 함수는 한글을 쓸 수 없으며, 쓸 수 있는 문자는 키보드로 
직접 입력 가능한 문자들로 제한된다. 주로 메뉴를 만들 때 쓰이며, 그 외에도 활용 가능한 곳은 많다.


-------------------------------
     mouse_cursor_off()
-------------------------------
원형 : void mouse_cursor_off( void )

  마우스 커서를 지운다. 그러나 단지 화면에서 안보이는 것이지 마우스 커서는 여전히 동작하며 그 좌표가 
바뀐다는 것을 잊으면 안된다.


-------------------------------
     mouse_cursor_on()
-------------------------------
원형 : void mouse_cursor_on( void )

  마우스 커서를 화면에 나타낸다.


-------------------------------
      music_position()
-------------------------------
원형 : dword music_posotion( void )

  현재 음악이 얼마나 진행 중인지를 알아낸다. 음악의 동기화에 유용하다.


-------------------------------
      null_function()
-------------------------------
원형 : void null_function( void )

  아무것도 하지 않는 함수이다. 프로그램의 판독성을 높히기 위해 만들었다. 나름대로 쓸모가 있다.


-------------------------------
     open_user_window()
-------------------------------
원형 : int open_user_window( int x, int y, word size_x, word size_y, window_data *window )

  화면에 사용자 정의 윈도우를 연다. 이 경우 보통의 윈도우와는 다른 형태를 취한다. 사용자 윈도우는 한
칸이 16x16으로 구성되어 있는데, 이 패러그래프의 갯수로 윈도우의 크기를 포현한다. 만약 이 크기가  2보
다 작을 경우엔 1을, 윈도우 사이즈가 너무 크면 2를 리턴한다.


-------------------------------
        open_window()
-------------------------------
원형 : int open_window( int start_x, int start_y, int end_x, int end_y, window_data *window )

  윈도우를 연다. 윈도우는 x, y의 크기가 각각 12보다 커야만 한다. 만약 성공적으로 윈도우가 열렸으면 0
을 리턴하고 그렇지 않으면 x크기가 작을 때 1을, y크기가 작을 때 2를 리턴한다.


-------------------------------
      output_voice()
-------------------------------
원형 : void (*output_voice)( voice_data data )

  읽어들인 보이스 화일을 스피커로 출력한다. 인수는 읽은 데이터의 포인터이다.


-------------------------------
       page_pointer()
-------------------------------
원형 : char *page_pointer( word page )

  주어진 페이지의 선두번지를 가리키는 포인터를 리턴해 준다. 생각보다 많이 쓰이는 함수.


-------------------------------
       play_midi()
-------------------------------
원형 : int play_midi( char *file_name )

  디스크에서 MDI화일을 읽어들여서 음악을 연주하기 시작한다. 도중에 새로운 음악을  시작하려면  반드시 
stop_music()를 호출한 후에 새로운 MDI화일을 연주해야 한다.


-------------------------------
        push_putton()
-------------------------------
원형 : void push_button( button_data *button )

  주어진 버튼을 누른다. 단지 눌러진 모습을  보여주는  것이므로  나중엔  다시  버튼을  올리고  싶으면 
release_button()함수를 써야 한다.


-------------------------------
      put_char_eng()
-------------------------------
원형 : void put_char_eng( int x, int y, char code, byte color )

  주어진 코드에 해당하는 한 문자의 영문을 찍는다. 코드는 물론 ASCII 코드이다.


-------------------------------
      put_char_han()
-------------------------------
원형 : void put_char_han( int x, int y, int code, byte color )

   주어진 코드에 해당하는 한 문자의 한글을 찍는다. 코드는 물론 KSSM 조합형 코드이다.


-------------------------------
      put_font_eng()
-------------------------------
원형 : void put_font_eng( int x, int y, byte *chr, byte color )

  폰트를 찍는다. 이 함수는 주로 전역변수 _english[], _special[]의 데이터를 바탕으로 화면상에  원하는 
폰트를 찍는데 단독으로는 별로 쓰이지 않고 다른 함수에 내부적으로 호출하여 쓰는 경우가 많다. 이  함수
를 쓰기 위해선 앞에서 미리 load_font() 함수를 호출해야 한다.


-------------------------------
       put_font_han()
-------------------------------
원형 : void put_font_han( int x, int y, word *chr, byte color )

  한글 폰트를 찍는다. 이 함수는 한글 16x16폰트를 찍는다는 점 외엔 put_font()함수와 동일한 일을 한다.


-------------------------------
     put_font_multi_eng()
-------------------------------
원형 : void put_font_multi_eng( int x, int y, byte *chr, byte start_color )

  put_font_eng()의 멀티컬러 버전


-------------------------------
      put_font_multi_han()
-------------------------------
원형 : void put_font_multi_han( int x, int y, word *chr, byte start_color )

   put_font_han()의 멀티컬러 버전


-------------------------------
          put_key()
-------------------------------
원형 : void put_key( int key )

  키 버퍼에 키 하나를 넣는다. 단, 이때 키 버퍼는 청소된다. 한정된 용도이긴 하지만 특별한  경우  무척 
유용하게 쓰일 수 있기 때문에 유용하다. get_key()함수도 단 한 문자의 키버퍼를 참조하기 때문이다.


-------------------------------
       put_menu_fnt()
-------------------------------
원형 : void put_menu_fnt( int x, int y, byte *chr, byte color )

  이것은 약간 다른 방식의 폰트를 찍는데, 바로 4x6폰트를 8비트의 반씩 나누어 찍는다. 그러므로  속도면
에서나 메모리 면에서 약간의 소득을 올릴 수 있다. 단지 폰트가 너무 작아서 판독성이 떨어진다는 것과 문
자 품이 망가진다는 것인데, 메뉴용 폰트로는 충분히 쓸 수 있다.


-------------------------------
       put_image()
-------------------------------
원형 : void put_image( int x, int y, image_data image, char option )

  get_image() 함수를 이용해 잡은 데이터를 화면에 찍는다. option은 이미지를 찍는 방식을 지정한다.
 'c' - Copy put
 'a' - And put
 'o' - Or put
 'x' - Xor put


-------------------------------
         put_pixel()
-------------------------------
원형 : void put_pixel( int x, int y, byte color )

  주어진 좌표에 인수로 받은 컬러로 점을 찍는다.


-------------------------------
       put_pixel_xor()
-------------------------------
원형 : void put_pixel_xor( int x, int y )

  주어진 좌표에 XOR속성으로 점을 찍는다.


-------------------------------
     recover_palette()
-------------------------------
원형 : void recover_palette( void )

   팔레트를 복구시킨다. 현재 있는 팔레트 배열 _palette[]를 이용해 다시 팔레트로 복구시킨다.


-------------------------------
     release_button()
-------------------------------
원형 : void release_button( button_data *button )

  push_button()함수에 의해 눌려진 버튼을 다시 올린다.


-------------------------------
       reply_quit()
-------------------------------
원형 : bool reply_quit( void )

  프로그램을 끝낼 것인지를 묻는다. '예'를 선택하면 TRUE, 그렇지 않으면 FALSE를 리턴한다. 간단하게 써
먹을 수 있는 유용한 함수이다.


-------------------------------
       reset_cycle()
-------------------------------
원형 : void reset_cycle( void )

  set_cycle()함수로 바뀐 인터럽트 1Ch를 원래대로 돌려 놓는다.


-------------------------------
     reset_multi_key()
-------------------------------
원형 : void reset_multi_key( void )

  set_multi_key()로 가로챈 키보드 인터럽트 9h를 원래대로 돌려 놓는다. 이후로 버퍼형 입출력 함수를 사
용하는 것이 가능하다.


-------------------------------
      restore_image()
-------------------------------
원형 : void restore_image( int handle, image_data *image )

  XMS로 옮긴 이미지를 다시 옮겨 온다. 인수는 옮긴 핸들과 이미지의 포인터로서, 이 경우에 자동으로  이
미지를 저장할 메모리를 할당하면, 이미지가 보관되어 있었던 XMS는 해제된다.


-------------------------------
      restore_screen()
-------------------------------
원형 : void restore_screen( int handle, word page )

  지정된 핸들의 그림을 XMS에서 해당 페이지로 옮긴다.


-------------------------------
         rotate()
-------------------------------
원형 : void rotate( int start_x, int start_y, int end_x, int end_y, char direct, word step )

  화면상의 지정된 부분을 로테이트 한다. 즉, 화면을 스크롤한 다음 스크롤되어 없어지는 부분을 다시  반
대편에 찍는 것이다. 게임의 배경스크롤에 무척 유용한 함수이다. 이것을 이용하면 소위 뺑뺑이 스크롤이라
는 것을 쉽게 구현할 수 있다.


-------------------------------
       sample_rate()
-------------------------------
원형 : void sample_rate( word rate )

  VOC출력시 샘플링 주파수를 설정한다. 이것은 사운드 블래스터 카드만 사용할 수 있다. 디폴트는 8 kHz이
다. 윈도우의 WAV화일은 11 kHz가 기본으로 되어 있기 때문에 윈도우의 WAV를 컨버트한  VOC화일의  경우엔 
이 함수를 인수 11000으로 호출해야 제대로 된 소릴 들을 수 있다. 경우엔 따라서는 같은 데이터를  출력하
는 샘플링 주파수만 다르게 해서 여러가지 소리로 출력하는 경우도 있는데 PC스피커에선 이런 효과를  쓰지 
못하므로 그것을 염두에 두기 바란다.


-------------------------------
          scroll()
-------------------------------
원형 : void scroll( int start_x, int start_y, int end_x, int end_y, char direct, word step )

  화면의 일부분을 스크롤 시킨다. 스크롤 시킨 후의 나머지 부분은 그대로 남아 있으니 사용자가 직접  지
워야 한다. step은 스크롤 되는 정도인데 이 함수는 속도를 중시했기 때문에 스크롤의 한계를 검사하는  루
틴이 없다. 그러므로 end가 start보다 더 작을 때나 step이 화면의 크기보다 크면 폭주하므로 주의하기  바
란다. direct는 스크롤 되는 방향이다.
 'u' - 윗쪽으로 스크롤된다.
 'd' - 아랫쪽으로 스크롤된다.
 'l' - 왼쪽으로 스크롤된다.
 'r' - 오른쪽으로 스크롤된다.
 이 함수는 내부적으로 scroll_up(), scroll_down()등 별도의 스크롤 함수를 불러 사용하므로 특별한  경우
르 제외하곤 직접 한방향 스크롤 함수를 쓰는 것이 낫다.


-------------------------------
        scroll_clear()
-------------------------------
원형 : void scroll_clear( int s_x, int s_y, int e_x, int e_y, char direct, word step )

  스크롤을 한 다음 잔상을 지운다. 잔상을 지우는 색상은 _attr_back_color이라는 변수의 색이며,  디폴트
는 검정색으로 되어 있다.


-------------------------------
       scroll_down()
-------------------------------
원형 : void scroll_down( int start_x, int start_y, int end_x, int end_y, word step )

  화면의 특정 부위를 아래로 스크롤한다. 나머지 부분은 scroll()함수와 동일하다.


-------------------------------
     scroll_down_screen()
-------------------------------
원형 : void scroll_down_screen( word step )

  화면의 전체를 아래로 스크롤 시킨다. scroll()함수와의 차이라면 화면 전체를 대상으로 했기 때문에  속
도가 빠르다는 장점이 있다. 그러나 scroll()함수처럼 화면의 일부분을 상하좌우로 스크롤시키지는 못한다.


-------------------------------
       scroll_left()
-------------------------------
원형 : void scroll_left( int start_x, int start_y, int end_x, int end_y, word step )

  화면의 특정 부위를 왼쪽으로 스크롤한다. 나머지 부분은 scroll()함수와 동일하다.


-------------------------------
       scroll_right()
-------------------------------
원형 : void scroll_right( int start_x, int start_y, int end_x, int end_y, word step )

  화면의 특정 부위를 오른쪽으로 스크롤한다. 나머지 부분은 scroll()함수와 동일하다.


-------------------------------
        scroll_up()
-------------------------------
원형 : void scroll_up( int start_x, int start_y, int end_x, int end_y, word step )

  화면의 특정 부위를 위로 스크롤한다. 나머지 부분은 scroll()함수와 동일하다.


-------------------------------
    scroll_up_screen()
-------------------------------
원형 : void scroll_up_screen( word step )

  scroll_up_screen()함수와 같으나 이 함수는 화면 전체를 위로 스크롤시킨다.


-------------------------------
     select_icon()
-------------------------------
원형 : int select_icon( icon_data icon, word disp )

  지정된 16x16아이콘을 표시하고 그중에 한 아이콘을 선택하여 그 번호를 리턴한다. ESC를 누르면  CANCEL
을 리턴한다. icon은 아이콘의 폰트 이미지의 선두번지를 나열한 배열이며, display_number는 한번에  표시
될 아이콘의 갯수이며 총 아이콘의 갯수를 이를 넘어갈 경우 커서키로 스크롤이 가능하다. max가 14을 넘어
가면 CANCEL을 리턴한다.


-------------------------------
     set_clip_window()
-------------------------------
원형 : void set_clip_window( int start_x, int start_y, int end_x, int end_y )

  클리핑 윈도우를 설정한다. 이 함수는 전역변수 _min_x, _min_y, _max_x, _max_y를 주어진 인수로 설정하
는 역할만을 한다. 초기 클리핑 윈도우는 ( 0, 0, 319, 199 )로 되어 있다.


-------------------------------
       set_cycle()
-------------------------------
원형 : void set_cycle( byte start_color, byte end_color, word delay_time )

  cycle_palette()함수를 인터럽트 1Ch에 등록 시킨다. 인수인 delay_time는 단위가 1/18초이다. 즉,  18을 
인수로 함수를 호출하면 약 1초에 한번씩 CPU의 동작과 상관없이 팔레트가 순환한다.  한가지,  프로그램을 
끝내기 전에 반드시 reset_cycle()함수를 호출해서 원래의 인터럽트로 돌려 놔야 한다.


-------------------------------
       set_monitor()
-------------------------------
원형 : void set_monitor( bool state )

  모니터를 끄거나 켠다. 이것은 화면에 지연이 큰 이미지를 처리할 때 시각적인 효과를 나타내기 위해  사
용하는 것이다. 주로 팔레트를 조작할 때 화면이 어지럽게 깜빡이는 것을 막기 위해 쓴다. 인수로 ON을  주
면 켜지고, OFF를 주면 화면이 꺼진다.


-------------------------------
     set_mouse_cursor()
-------------------------------
원형 : void set_mouse_cursor( image_data cursor_data )

  마우스 커서를 설정한다. 마우스 커서는 16x16의 아이콘과 같은 형식으로 되어 있으며, 투명색 체크를 한
다. 인수로 그 커서의 아이콘 데이터를 넘겨주면 커서가 세트된다.


-------------------------------
     set_mouse_mickey()
-------------------------------
원형 : void set_mouse_mickey( word x_mickey, word y_mickey )

  마우스의 이동 간격을 조절한다. 단위는 미키이다.


-------------------------------
      set_mouse_speed()
-------------------------------
원형 : void set_mouse_speed( word x, word y, word double_speed )

  마우스의 감도를 조절한다.


-------------------------------
     set_mouse_window()
-------------------------------
원형 : void set_mouse_window( int start_x, int start_y, int end_x, int end_y )

  마우스 커서의 활동 범위를 설정한다. 초기값은 화면 전체로 설정되어 있다. 단, 인수로 주어진 값이  클
리핑 윈도우보다 크면 클리핑 윈도우에 맞추도록 되어 있다.


-------------------------------
     set_multi_key()
-------------------------------
원형 : void set_multi_key( void )

  멀티키를 초기화 시킨다. 이 함수는 키보드 인터럽트 9h를 가로채어 구조체 _key를 세트하므로, 이  함수
를 호출한 이후에는 get_key(), action_key()와 같은 버퍼형 입출력 함수는 사용할 수 없게 된다. 이  함수
를 호출한 후에는 _key.scan[]에 현재의 키 상태가 세트되므로 주로 액션 게임을 만들 때 사용된다. 더  자
세한 내용은 User's Guide를 참조하기 바란다.


-------------------------------
     set_music_volume()
-------------------------------
원형 : void set_music_volume_( word volume )

  출력되는 음악의 볼륨을 조정한다. 볼륨의 범위는 0~127까지이며 음악이 연주되고 있는 동안만 유효하다.


-------------------------------
        set_palette()
-------------------------------
원형 : void set_palette( byte color_no, char red, char green, char blue )

  팔레트를 설정한다. 먼저 색번호를 넣고, 차례로 Red, Green, Blue성분을 넣으면 팔레트가 세트된다.  R, 
G, B 성분은 0부터 63까지의 값을 갖는다.


-------------------------------
     set_mouse_window()
-------------------------------
원형 : void set_mouse_window( int start_x, int start_y, int end_x, int end_y )

  마우스 커서의 윈도우를 설정한다. 이렇게 설정된 윈도우가 마우스가 움직일 경계가 된다.


-------------------------------
       state_mouse()
-------------------------------
원형 : int state_mouse( int *x, int *y )

  현재의 마우스 커서의 상태를 나타낸다. 마우스 커서의 x, y좌표는 포인터로 보낸 인수에 담겨져 오고 마
우스 버튼의 상태가 리턴값으로 넘어온다.
 1 - 왼쪽 버튼이 눌러졌다.
 2 - 오른쪽 버튼이 눌러졌다.
 3 - 오른쪽, 왼쪽 버튼이 동시에 눌러졌다.


-------------------------------
      stencil_put()
-------------------------------
원형 : void stencil_put( int x, int y, image_data image, byte stencil )

  지정된 컬러에 해당하는 화면상의 컬러를 보존하면서 이미지를 찍는다. 이 함수를 이용하면 상당히  복잡
한 이미지처리도 쉽게 할 수 있다.
 

-------------------------------
     stencil_put_opp()
-------------------------------
원형 : void stencil_put_opp( int x, int y, image_data image, byte opp_stencil )

  정해진 색에 해당하는 화면에다만 이미지를 찍는다. stencil_put()과 반대의 작용을 한다.


-------------------------------
        stop_music()
-------------------------------
원형 : void stop_music( void )

  음악을 멈추고 메모리를 해제한다. 만약 음악을 연주하는 도중에 다른 음악으로 바꾸고 싶으면 이 함수를 
먼저 호출해 줘야 한다. 음악을 위해 할당한 메모리를 해제해야 하기 때문이다.


-------------------------------
        stop_voice()
-------------------------------
원형 : void stop_voice( void )

  음성의 출력을 멈춘다. 사블의 경우에만 가능하다. PC스피커의 경우엔 close_voice()함수를 쓰면 같은 효
과를 볼 수 있다.


-------------------------------
        store_image()
-------------------------------
원형 : int store_image( image_data image )

  원하는 이미지를 XMS로 옮긴다. 이때 자동으로 XMS를 할당하지만 따로  해제시킬  필요는  없다.  나중에 
restore_image()로 이미지를 옮겨 올 때 자동으로 할당된 XMS를 해제시키기 때문이다. 이미지를 옮기는  순
간 현재의 이미지는 farfree()로 해제된다.


-------------------------------
       store_screen()
-------------------------------
원형 : int store_screen( word page )

  지정된 페이지의 화면을 XMS로 옮긴다. 이때 자동으로 해당 크기의 XMS를  할당하므로  필요가  없어지면 
xms_free()로 해제해야 한다. 리턴값은 할당된 XMS의 핸들이다.


-------------------------------
          str()
-------------------------------
원형 : char *str( int number )

  입력받은 숫자를 문자열로 바꾸어 리턴한다. 이때 함수의 내부에선 문자열을 위해 static형 배열을  잡아
놓고 있으니 이 함수는 중복적으로 사용하면 원래의 문자열은 파괴된다. 즉 한번 표시하고 버릴 데이터에나 
사용하고 계속 참조하기 위해선 strcpy()함수등을 이용해서 따로 보존해야 한다. 이 함수는 make_str()함수
등에서 사용하면 무척 편리하다.


-------------------------------
        str_hex()
-------------------------------
원형 : char *str_hex( int number )

  str()함수와 같으나 HEX값으로 바꾸어 준다. 이 함수도 str()처럼 중복해서 사용하면 원래의 값이 사라진
다. 뿐만 아니라 str()과도 함께 사용하면 같은 결과를 초래한다.


-------------------------------
         tv_noise()
-------------------------------
원형 : void tv_noise( void )

  텔레비전의 노이즈를 구현한다. 이 함수는 난수로 만들어지기 때문에 반복해서 호출하면 화면이 마구  일
그러지는 효과를 낼 수 있다. 단, 한 화면만을 그려내는 것이므로 실제 TV의 노이즈 효과를 내려면  반복해
서 호출해 주어야 한다. 사용하는 색상은 0번과 255번의 단 두 색만이다.


-------------------------------
      tv_noise_clip()
-------------------------------
원형 : void tv_noise_clip( void )

  tv_noise()의 클리핑 버전


-------------------------------
          xchg_hl()
-------------------------------
원형 : int xchg_hl( int data )

  주어진 데이터의 상, 하위 바이트를 교환한다.


-------------------------------
         xms_alloc()
-------------------------------
원형 : int xms_alloc( word size )

  XMS에 메모리를 할당한다. Size는 KB단위이며, 성공적으로 할당되면 그 핸들이 리턴된다.


-------------------------------
        xms_free()
-------------------------------
원형 : int xms_free( int handle )

  xms_alloc()로 할당된 XMS메모리를 해제한다.


-------------------------------
        xms_install()
-------------------------------
원형 : int xms_install( void )

  XMM의 설치 여부를 확인하고 XMM이 지원하는 API를 설치한다. XMS에 관련된 함수를 사용하기 앞서 반드시 
한번은 실행해야 한다.


-------------------------------
         xms_lock()
-------------------------------
원형 : int xms_lock( int handle, long *linear_addr );

  XMS에 할당된 메모리를 보호한다. 무사히 잠그면 0을 리턴하지만 그 외의 값은 에러코드이다.



-------------------------------
          xms_pop()
-------------------------------
원형 : int xms_pop( int handle, char *data, dword length )

  XMS에서 원하는 길이만큼 지정된 포인터로 옮긴다. 무사히 옮기게 되면 0을 리턴하지만 그 외의 값은  에
러코드이다.



-------------------------------
         xms_push()
-------------------------------
원형 : int xms_push( int handle, char *data, dword length )

  기본 메모리의 지정된 포인터에서 원하는 길이만큼 데이터를 XMS로 옮긴다. 무사히 옮기게 되면 0을 리턴
하지만 그 외의 값은 에러코드이다.


-------------------------------
        xms_realloc()
-------------------------------
원형 : int xms_realloc( int handle, word new_size )

  지정된 핸들의 XMS메모리를 재할당한다. 무사히 재할당되면 0을 리턴하지만 그 외의 값은 에러코드이다.



-------------------------------
         xms_size()
-------------------------------
원형 : int xms_size( int option )

  현재 남은 XMS의 사이즈를 리턴한다. 인수는 FREE_SIZE와 LARGEST_SIZE를 줄 수 있는데, FREE_SIZE는  총 
사이즈이고 LARGEST_SIZE는 한번에 할당할 수 있는 최대 크기의 XMS를 리턴한다.


-------------------------------
        xms_unlock()
-------------------------------
원형 : int xms_unlock( int handle )

  Lock된 XMS를 Unlock한다. 무사히 풀면 0을 리턴하지만 그 외의 값은 에러코드이다.


-------------------------------
        yes_or_no()
-------------------------------
원형 : bool yes_or_no( void )

  화면에 '예', '아니오'를 표시하고 선택하도록 한다. '예'를 선택하면 TRUE, 그렇지 않으면 FALSE를 리턴
한다. 



                                >>> 감사합니다 <<<
